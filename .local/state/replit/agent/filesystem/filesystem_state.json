{"file_contents":{"Program.cs":{"content":"using GasPipelineOptimization.Models;\nusing GasPipelineOptimization.Services;\nusing System.Text.Json;\n\nnamespace GasPipelineOptimization\n{\n    /// <summary>\n    /// Main program demonstrating the gas pipeline optimization system\n    /// </summary>\n    class Program\n    {\n        static async Task Main(string[] args)\n        {\n            Console.WriteLine(\"=== Gas Pipeline Capacity Planning & Optimization System ===\");\n            Console.WriteLine(\"Using Google OR-Tools for mathematical optimization\");\n            Console.WriteLine();\n\n            try\n            {\n                // Initialize the optimization engine\n                var optimizationEngine = new OptimizationEngine();\n\n                // Load network configuration\n                PipelineNetwork network;\n                if (args.Length > 0 && File.Exists(args[0]))\n                {\n                    Console.WriteLine($\"Loading network from: {args[0]}\");\n                    network = PipelineNetwork.LoadFromJson(args[0]);\n                }\n                else\n                {\n                    Console.WriteLine(\"Loading default network configuration...\");\n                    network = LoadDefaultNetwork();\n                }\n\n                Console.WriteLine($\"Loaded network: {network}\");\n                Console.WriteLine();\n\n                // Validate the network\n                if (!network.IsValid(out List<string> networkErrors))\n                {\n                    Console.WriteLine(\"Network validation failed:\");\n                    foreach (var error in networkErrors)\n                    {\n                        Console.WriteLine($\"  - {error}\");\n                    }\n                    return;\n                }\n\n                Console.WriteLine(\"Network validation passed.\");\n                Console.WriteLine();\n\n                // Display available algorithms\n                Console.WriteLine(\"Available optimization algorithms:\");\n                foreach (var algorithmName in optimizationEngine.GetAvailableAlgorithms())\n                {\n                    var algorithm = optimizationEngine.GetAlgorithm(algorithmName);\n                    Console.WriteLine($\"  - {algorithmName}: {algorithm?.Description}\");\n                }\n                Console.WriteLine();\n\n                // Interactive menu\n                await RunInteractiveMenu(optimizationEngine, network);\n            }\n            catch (Exception ex)\n            {\n                Console.WriteLine($\"Fatal error: {ex.Message}\");\n                if (ex.InnerException != null)\n                {\n                    Console.WriteLine($\"Inner exception: {ex.InnerException.Message}\");\n                }\n                Console.WriteLine(\"\\nPress any key to exit...\");\n                try\n                {\n                    Console.ReadKey();\n                }\n                catch (InvalidOperationException)\n                {\n                    // Handle automation environments where console input is redirected\n                    Console.WriteLine(\"Application completed.\");\n                }\n            }\n        }\n\n        static async Task RunInteractiveMenu(OptimizationEngine engine, PipelineNetwork network)\n        {\n            while (true)\n            {\n                Console.WriteLine(\"\\n=== Main Menu ===\");\n                Console.WriteLine(\"1. Run Single Optimization\");\n                Console.WriteLine(\"2. Compare Multiple Algorithms\");\n                Console.WriteLine(\"3. Scenario Analysis\");\n                Console.WriteLine(\"4. Network Information\");\n                Console.WriteLine(\"5. Settings Configuration\");\n                Console.WriteLine(\"6. Export Results\");\n                Console.WriteLine(\"0. Exit\");\n                Console.Write(\"Select option: \");\n\n                var choice = Console.ReadLine();\n\n                switch (choice)\n                {\n                    case \"1\":\n                        await RunSingleOptimization(engine, network);\n                        break;\n                    case \"2\":\n                        await CompareAlgorithms(engine, network);\n                        break;\n                    case \"3\":\n                        await RunScenarioAnalysis(engine, network);\n                        break;\n                    case \"4\":\n                        DisplayNetworkInformation(network);\n                        break;\n                    case \"5\":\n                        await ConfigureSettings();\n                        break;\n                    case \"6\":\n                        await ExportResults(engine, network);\n                        break;\n                    case \"0\":\n                        Console.WriteLine(\"Goodbye!\");\n                        return;\n                    default:\n                        Console.WriteLine(\"Invalid option. Please try again.\");\n                        break;\n                }\n            }\n        }\n\n        static async Task RunSingleOptimization(OptimizationEngine engine, PipelineNetwork network)\n        {\n            Console.WriteLine(\"\\n=== Single Optimization ===\");\n            \n            // Select algorithm\n            var algorithms = engine.GetAvailableAlgorithms().ToList();\n            Console.WriteLine(\"Available algorithms:\");\n            for (int i = 0; i < algorithms.Count; i++)\n            {\n                Console.WriteLine($\"{i + 1}. {algorithms[i]}\");\n            }\n            \n            Console.Write(\"Select algorithm (1-\" + algorithms.Count + \"): \");\n            if (!int.TryParse(Console.ReadLine(), out int algorithmIndex) || \n                algorithmIndex < 1 || algorithmIndex > algorithms.Count)\n            {\n                Console.WriteLine(\"Invalid selection.\");\n                return;\n            }\n\n            var selectedAlgorithm = algorithms[algorithmIndex - 1];\n            \n            // Configure settings\n            var settings = ConfigureOptimizationSettings();\n            \n            Console.WriteLine($\"\\nRunning optimization with {selectedAlgorithm}...\");\n            var startTime = DateTime.Now;\n            \n            var result = engine.RunOptimization(selectedAlgorithm, network, settings);\n            \n            var endTime = DateTime.Now;\n            Console.WriteLine($\"Optimization completed in {(endTime - startTime).TotalMilliseconds:F0} ms\");\n            Console.WriteLine();\n            \n            // Display results\n            Console.WriteLine(result.GenerateSummaryReport());\n            \n            // Validate result\n            if (engine.ValidateOptimizationResult(result, network, out List<string> validationErrors))\n            {\n                Console.WriteLine(\"✓ Result validation passed.\");\n            }\n            else\n            {\n                Console.WriteLine(\"✗ Result validation failed:\");\n                foreach (var error in validationErrors)\n                {\n                    Console.WriteLine($\"  - {error}\");\n                }\n            }\n\n            Console.WriteLine(\"\\nPress any key to continue...\");\n            Console.ReadKey();\n        }\n\n        static async Task CompareAlgorithms(OptimizationEngine engine, PipelineNetwork network)\n        {\n            Console.WriteLine(\"\\n=== Algorithm Comparison ===\");\n            \n            var settings = ConfigureOptimizationSettings();\n            var algorithms = engine.GetAvailableAlgorithms().ToList();\n            \n            Console.WriteLine(\"Running all algorithms for comparison...\");\n            Console.WriteLine();\n            \n            var results = engine.RunMultipleOptimizations(algorithms, network, settings);\n            \n            var report = engine.GenerateComparativeReport(results);\n            Console.WriteLine(report);\n            \n            Console.WriteLine(\"Press any key to continue...\");\n            Console.ReadKey();\n        }\n\n        static async Task RunScenarioAnalysis(OptimizationEngine engine, PipelineNetwork network)\n        {\n            Console.WriteLine(\"\\n=== Scenario Analysis ===\");\n            \n            // Create scenarios\n            var scenarios = new Dictionary<string, PipelineNetwork>\n            {\n                { \"Baseline\", network },\n                { \"High Demand\", CreateHighDemandScenario(network) },\n                { \"Compressor Outage\", CreateCompressorOutageScenario(network) },\n                { \"Segment Maintenance\", CreateSegmentMaintenanceScenario(network) }\n            };\n            \n            Console.WriteLine(\"Available scenarios:\");\n            foreach (var scenario in scenarios.Keys)\n            {\n                Console.WriteLine($\"  - {scenario}\");\n            }\n            \n            Console.Write(\"Select algorithm for scenario analysis: \");\n            var algorithms = engine.GetAvailableAlgorithms().ToList();\n            for (int i = 0; i < algorithms.Count; i++)\n            {\n                Console.WriteLine($\"{i + 1}. {algorithms[i]}\");\n            }\n            \n            if (!int.TryParse(Console.ReadLine(), out int algorithmIndex) || \n                algorithmIndex < 1 || algorithmIndex > algorithms.Count)\n            {\n                Console.WriteLine(\"Invalid selection.\");\n                return;\n            }\n            \n            var selectedAlgorithm = algorithms[algorithmIndex - 1];\n            var settings = ConfigureOptimizationSettings();\n            \n            Console.WriteLine($\"\\nRunning scenario analysis with {selectedAlgorithm}...\");\n            \n            var results = engine.RunScenarioAnalysis(selectedAlgorithm, scenarios, settings);\n            \n            Console.WriteLine(\"\\n=== Scenario Analysis Results ===\");\n            foreach (var result in results)\n            {\n                Console.WriteLine($\"\\n--- {result.Key} Scenario ---\");\n                if (result.Value.Status == OptimizationStatus.Optimal || result.Value.Status == OptimizationStatus.Feasible)\n                {\n                    Console.WriteLine($\"Status: {result.Value.Status}\");\n                    Console.WriteLine($\"Total Cost: ${result.Value.TotalCost.TotalCost:F2}\");\n                    Console.WriteLine($\"Throughput: {result.Value.Metrics.TotalThroughput:F2} MMscfd\");\n                    Console.WriteLine($\"Average Utilization: {result.Value.Metrics.AverageCapacityUtilization:F1}%\");\n                }\n                else\n                {\n                    Console.WriteLine($\"Failed: {result.Value.Status}\");\n                    if (result.Value.Messages.Any())\n                    {\n                        Console.WriteLine($\"Messages: {string.Join(\", \", result.Value.Messages)}\");\n                    }\n                }\n            }\n            \n            Console.WriteLine(\"\\nPress any key to continue...\");\n            Console.ReadKey();\n        }\n\n        static void DisplayNetworkInformation(PipelineNetwork network)\n        {\n            Console.WriteLine(\"\\n=== Network Information ===\");\n            Console.WriteLine($\"Name: {network.Name}\");\n            Console.WriteLine($\"Description: {network.Description}\");\n            Console.WriteLine();\n            \n            Console.WriteLine($\"Points: {network.Points.Count}\");\n            Console.WriteLine($\"  - Receipt Points: {network.GetReceiptPoints().Count()}\");\n            Console.WriteLine($\"  - Delivery Points: {network.GetDeliveryPoints().Count()}\");\n            Console.WriteLine($\"  - Compressor Stations: {network.GetCompressorStations().Count()}\");\n            Console.WriteLine();\n            \n            Console.WriteLine($\"Segments: {network.Segments.Count}\");\n            Console.WriteLine($\"  - Active Segments: {network.GetActiveSegments().Count()}\");\n            Console.WriteLine();\n            \n            Console.WriteLine($\"Total Supply Capacity: {network.GetTotalSupplyCapacity():F2} MMscfd\");\n            Console.WriteLine($\"Total Demand Requirement: {network.GetTotalDemandRequirement():F2} MMscfd\");\n            Console.WriteLine();\n            \n            // Display points\n            Console.WriteLine(\"=== Points ===\");\n            foreach (var point in network.Points.Values.OrderBy(p => p.Id))\n            {\n                Console.WriteLine($\"{point.Id}: {point.Name} ({point.Type})\");\n                if (point.Type == PointType.Receipt)\n                {\n                    Console.WriteLine($\"  Supply Capacity: {point.SupplyCapacity:F2} MMscfd\");\n                }\n                else if (point.Type == PointType.Delivery)\n                {\n                    Console.WriteLine($\"  Demand: {point.DemandRequirement:F2} MMscfd\");\n                }\n                else if (point.Type == PointType.Compressor)\n                {\n                    Console.WriteLine($\"  Max Pressure Boost: {point.MaxPressureBoost:F1} psi\");\n                    Console.WriteLine($\"  Fuel Rate: {point.FuelConsumptionRate:F4} MMscf/MMscfd\");\n                }\n                Console.WriteLine($\"  Pressure Range: {point.MinPressure:F1}-{point.MaxPressure:F1} psia\");\n            }\n            \n            Console.WriteLine(\"\\n=== Segments ===\");\n            foreach (var segment in network.Segments.Values.OrderBy(s => s.Id))\n            {\n                Console.WriteLine($\"{segment.Id}: {segment.Name}\");\n                Console.WriteLine($\"  From: {segment.FromPointId} To: {segment.ToPointId}\");\n                Console.WriteLine($\"  Capacity: {segment.Capacity:F2} MMscfd\");\n                Console.WriteLine($\"  Length: {segment.Length:F1} miles\");\n                Console.WriteLine($\"  Transport Cost: ${segment.TransportationCost:F3}/MMscf\");\n            }\n            \n            Console.WriteLine(\"\\nPress any key to continue...\");\n            Console.ReadKey();\n        }\n\n        static async Task ConfigureSettings()\n        {\n            Console.WriteLine(\"\\n=== Settings Configuration ===\");\n            Console.WriteLine(\"Current settings will be displayed and can be modified.\");\n            \n            // This would implement a settings editor\n            Console.WriteLine(\"Settings configuration not yet implemented.\");\n            Console.WriteLine(\"Using default settings for all optimizations.\");\n            \n            Console.WriteLine(\"\\nPress any key to continue...\");\n            Console.ReadKey();\n        }\n\n        static async Task ExportResults(OptimizationEngine engine, PipelineNetwork network)\n        {\n            Console.WriteLine(\"\\n=== Export Results ===\");\n            \n            var settings = ConfigureOptimizationSettings();\n            var algorithms = engine.GetAvailableAlgorithms().ToList();\n            \n            Console.WriteLine(\"Generating comprehensive results export...\");\n            \n            var results = engine.RunMultipleOptimizations(algorithms, network, settings);\n            \n            var timestamp = DateTime.Now.ToString(\"yyyyMMdd_HHmmss\");\n            var filename = $\"optimization_results_{timestamp}.txt\";\n            \n            var report = engine.GenerateComparativeReport(results);\n            \n            try\n            {\n                await File.WriteAllTextAsync(filename, report);\n                Console.WriteLine($\"Results exported to: {filename}\");\n            }\n            catch (Exception ex)\n            {\n                Console.WriteLine($\"Export failed: {ex.Message}\");\n            }\n            \n            Console.WriteLine(\"\\nPress any key to continue...\");\n            Console.ReadKey();\n        }\n\n        static OptimizationSettings ConfigureOptimizationSettings()\n        {\n            Console.WriteLine(\"\\nOptimization Settings:\");\n            Console.Write(\"Enable pressure constraints? (y/n) [y]: \");\n            var pressureInput = ReadLineWithDefault(\"\");\n            var enablePressure = string.IsNullOrEmpty(pressureInput) || pressureInput.ToLower().StartsWith(\"y\");\n            \n            Console.Write(\"Enable compressor stations? (y/n) [y]: \");\n            var compressorInput = ReadLineWithDefault(\"\");\n            var enableCompressors = string.IsNullOrEmpty(compressorInput) || compressorInput.ToLower().StartsWith(\"y\");\n            \n            Console.Write(\"Maximum solution time (seconds) [300]: \");\n            var timeInput = ReadLineWithDefault(\"300\");\n            var maxTime = double.TryParse(timeInput, out var parsedTime) ? parsedTime : 300.0;\n            \n            Console.Write(\"Preferred solver (GLOP/SCIP) [GLOP]: \");\n            var solverInput = ReadLineWithDefault(\"GLOP\");\n            var solver = string.IsNullOrEmpty(solverInput) ? \"GLOP\" : solverInput.ToUpper();\n            \n            return new OptimizationSettings\n            {\n                EnablePressureConstraints = enablePressure,\n                EnableCompressorStations = enableCompressors,\n                MaxSolutionTimeSeconds = maxTime,\n                PreferredSolver = solver,\n                EnableDetailedLogging = true\n            };\n        }\n\n        static PipelineNetwork LoadDefaultNetwork()\n        {\n            var configPath = \"config.json\";\n            if (File.Exists(configPath))\n            {\n                return PipelineNetwork.LoadFromJson(configPath);\n            }\n            else\n            {\n                // Create a simple default network\n                var network = new PipelineNetwork\n                {\n                    Name = \"Default Test Network\",\n                    Description = \"Simple gas pipeline network for testing optimization algorithms\"\n                };\n\n                // Add points\n                network.AddPoint(new Point(\"R1\", \"Receipt Point 1\", PointType.Receipt)\n                {\n                    SupplyCapacity = 1000,\n                    MinPressure = 800,\n                    MaxPressure = 1000,\n                    CurrentPressure = 950,\n                    UnitCost = 2.50\n                });\n\n                network.AddPoint(new Point(\"D1\", \"Delivery Point 1\", PointType.Delivery)\n                {\n                    DemandRequirement = 600,\n                    MinPressure = 300,\n                    MaxPressure = 800,\n                    CurrentPressure = 500\n                });\n\n                network.AddPoint(new Point(\"D2\", \"Delivery Point 2\", PointType.Delivery)\n                {\n                    DemandRequirement = 400,\n                    MinPressure = 300,\n                    MaxPressure = 800,\n                    CurrentPressure = 500\n                });\n\n                network.AddPoint(new Point(\"C1\", \"Compressor Station 1\", PointType.Compressor)\n                {\n                    MinPressure = 300,\n                    MaxPressure = 1200,\n                    CurrentPressure = 600,\n                    MaxPressureBoost = 400,\n                    FuelConsumptionRate = 0.02\n                });\n\n                // Add segments\n                network.AddSegment(new Segment(\"S1\", \"Main Line 1\", \"R1\", \"C1\", 800)\n                {\n                    Length = 50,\n                    Diameter = 36,\n                    FrictionFactor = 0.015,\n                    TransportationCost = 0.10\n                });\n\n                network.AddSegment(new Segment(\"S2\", \"Distribution Line 1\", \"C1\", \"D1\", 600)\n                {\n                    Length = 30,\n                    Diameter = 24,\n                    FrictionFactor = 0.018,\n                    TransportationCost = 0.12\n                });\n\n                network.AddSegment(new Segment(\"S3\", \"Distribution Line 2\", \"C1\", \"D2\", 500)\n                {\n                    Length = 40,\n                    Diameter = 20,\n                    FrictionFactor = 0.020,\n                    TransportationCost = 0.15\n                });\n\n                // Calculate pressure drop constants\n                foreach (var segment in network.Segments.Values)\n                {\n                    segment.CalculatePressureDropConstant();\n                }\n\n                return network;\n            }\n        }\n\n        static PipelineNetwork CreateHighDemandScenario(PipelineNetwork baseNetwork)\n        {\n            var scenario = JsonSerializer.Deserialize<PipelineNetwork>(\n                JsonSerializer.Serialize(baseNetwork), \n                new JsonSerializerOptions { PropertyNameCaseInsensitive = true });\n            \n            scenario!.Name = baseNetwork.Name + \" - High Demand\";\n            scenario.Description = \"Scenario with 50% increased demand\";\n            \n            foreach (var point in scenario.GetDeliveryPoints())\n            {\n                point.DemandRequirement *= 1.5;\n            }\n            \n            return scenario;\n        }\n\n        static PipelineNetwork CreateCompressorOutageScenario(PipelineNetwork baseNetwork)\n        {\n            var scenario = JsonSerializer.Deserialize<PipelineNetwork>(\n                JsonSerializer.Serialize(baseNetwork),\n                new JsonSerializerOptions { PropertyNameCaseInsensitive = true });\n            \n            scenario!.Name = baseNetwork.Name + \" - Compressor Outage\";\n            scenario.Description = \"Scenario with compressor stations offline\";\n            \n            foreach (var compressor in scenario.GetCompressorStations())\n            {\n                compressor.IsActive = false;\n            }\n            \n            return scenario;\n        }\n\n        static PipelineNetwork CreateSegmentMaintenanceScenario(PipelineNetwork baseNetwork)\n        {\n            var scenario = JsonSerializer.Deserialize<PipelineNetwork>(\n                JsonSerializer.Serialize(baseNetwork),\n                new JsonSerializerOptions { PropertyNameCaseInsensitive = true });\n            \n            scenario!.Name = baseNetwork.Name + \" - Maintenance\";\n            scenario.Description = \"Scenario with reduced segment capacity for maintenance\";\n            \n            // Reduce capacity of first segment by 50%\n            var firstSegment = scenario.GetActiveSegments().FirstOrDefault();\n            if (firstSegment != null)\n            {\n                firstSegment.Capacity *= 0.5;\n            }\n            \n            return scenario;\n        }\n\n        static string ReadLineWithDefault(string defaultValue)\n        {\n            try\n            {\n                var input = Console.ReadLine();\n                return string.IsNullOrEmpty(input) ? defaultValue : input;\n            }\n            catch (InvalidOperationException)\n            {\n                // Console input is redirected, use default\n                Console.WriteLine(defaultValue);\n                return defaultValue;\n            }\n        }\n    }\n}\n","size_bytes":22583},"replit.md":{"content":"# Gas Pipeline Network Capacity Planning System\n\n## Overview\n\nThis is a gas pipeline network capacity planning and optimization system designed to support commercial operations in natural gas transmission. The system models pipeline infrastructure including supply sources (receipt points), delivery points, compressor stations, and pipeline segments to enable efficient capacity management, operational planning, and commercial optimization.\n\nThe application focuses on integrating operational data with commercial rules and market requirements to maximize throughput, minimize operational costs, and support regulatory compliance for gas pipeline operators.\n\n## User Preferences\n\nPreferred communication style: Simple, everyday language.\n\n## System Architecture\n\n### Core Data Model\n- **Point-based Architecture**: The system uses a point-centric model where each network node (receipt points, delivery points, compressor stations) is defined with comprehensive operational and commercial attributes\n- **Configuration-driven Design**: Network topology and operational parameters are stored in JSON configuration files, enabling flexible network modeling without code changes\n- **Pressure and Flow Management**: Each point maintains pressure constraints (min/max), current operating conditions, and capacity limits to support hydraulic modeling\n\n### Network Topology Management\n- **Graph-based Network Representation**: Pipeline segments connect points to form a directed graph representing gas flow paths\n- **Multi-type Node Support**: Handles different point types (Receipt, Delivery, Compressor) with type-specific operational characteristics\n- **Spatial Positioning**: Includes coordinate system (x,y) for network visualization and geographic representation\n\n### Capacity Planning Engine\n- **Supply and Demand Modeling**: Tracks supply capacity at receipt points and demand requirements at delivery points\n- **Constraint-based Optimization**: Incorporates pressure constraints, compressor boost capabilities, and fuel consumption rates\n- **Cost Optimization**: Includes unit costs and operational expenses for economic optimization scenarios\n\n### Operational State Management\n- **Real-time Status Tracking**: Maintains current operational state (pressures, flows, active/inactive status)\n- **Dynamic Configuration**: Supports runtime changes to network configuration and operational parameters\n- **Fuel Consumption Modeling**: Tracks compressor fuel usage rates for operational cost calculations\n\n## External Dependencies\n\n### Infrastructure Integration Points\n- **SCADA Systems**: Integration capability for real-time operational data from pipeline control systems\n- **Hydraulic Simulation Tools**: Designed to work with tools like Synergi Gas or Pipeline Studio for physical capacity validation\n- **GIS/Asset Management**: Integration points for infrastructure topology and asset information\n\n### Commercial System Integration\n- **Contract Management Systems**: Interface for tracking shipper agreements and capacity rights\n- **Nomination/Scheduling Systems**: Integration for daily operational nominations and capacity utilization\n- **Billing Systems**: Connection points for commercial settlements and capacity charges\n\n### Regulatory and Reporting\n- **Regulatory Reporting Systems**: Support for compliance reporting to regulatory bodies (CER/FERC)\n- **Market Systems**: Integration capability for secondary capacity market transactions\n\n### Optional Advanced Integrations\n- **AI/ML Platforms**: Framework for predictive analytics and demand forecasting\n- **Digital Twin Systems**: Integration points for real-time operational comparison and validation","size_bytes":3662},"Algorithms/BalanceDemandAlgorithm.cs":{"content":"using Google.OrTools.LinearSolver;\nusing GasPipelineOptimization.Models;\nusing GasPipelineOptimization.Services;\n\nnamespace GasPipelineOptimization.Algorithms\n{\n    /// <summary>\n    /// Algorithm to balance demand across multiple paths while minimizing variance in utilization\n    /// </summary>\n    public class BalanceDemandAlgorithm : IOptimizationAlgorithm\n    {\n        public string Name => \"Balance Demand\";\n        public string Description => \"Balances gas flow across multiple paths to minimize utilization variance and improve network resilience\";\n\n        private readonly PressureConstraintService _pressureService;\n        private readonly CompressorService _compressorService;\n\n        public BalanceDemandAlgorithm()\n        {\n            _pressureService = new PressureConstraintService();\n            _compressorService = new CompressorService();\n        }\n\n        public bool CanHandle(PipelineNetwork network, OptimizationSettings settings)\n        {\n            // This algorithm works best with networks that have multiple paths\n            var receiptPoints = network.GetReceiptPoints().Count();\n            var deliveryPoints = network.GetDeliveryPoints().Count();\n            return network.IsValid(out _) && receiptPoints >= 1 && deliveryPoints >= 1;\n        }\n\n        public Dictionary<string, string> GetParameters()\n        {\n            return new Dictionary<string, string>\n            {\n                { \"BalanceWeight\", \"Weight for utilization balance objective (default: 1.0)\" },\n                { \"ThroughputWeight\", \"Weight for throughput maximization (default: 0.5)\" },\n                { \"CostWeight\", \"Weight for cost minimization (default: 0.3)\" },\n                { \"TargetUtilization\", \"Target utilization percentage for segments (default: 70)\" },\n                { \"UtilizationTolerance\", \"Tolerance for utilization variance (default: 10)\" },\n                { \"PathDiversityBonus\", \"Bonus for using multiple paths (default: 0.1)\" }\n            };\n        }\n\n        public OptimizationResult Optimize(PipelineNetwork network, OptimizationSettings settings)\n        {\n            var startTime = DateTime.Now;\n            var result = new OptimizationResult\n            {\n                AlgorithmUsed = Name,\n                Status = OptimizationStatus.NotSolved\n            };\n\n            try\n            {\n                // Determine solver type based on constraints\n                var solverType = DetermineSolverType(settings);\n                result.SolverUsed = solverType;\n\n                using var solver = Solver.CreateSolver(solverType);\n                if (solver == null)\n                {\n                    result.Status = OptimizationStatus.Error;\n                    result.Messages.Add($\"Failed to create {solverType} solver\");\n                    return result;\n                }\n\n                // Set solver parameters\n                ConfigureSolver(solver, settings);\n\n                // Create decision variables\n                var flowVars = CreateFlowVariables(solver, network);\n                var pressureVars = CreatePressureVariables(solver, network, settings);\n                var compressorVars = CreateCompressorVariables(solver, network, settings);\n                var balanceVars = CreateBalanceVariables(solver, network);\n\n                // Add constraints\n                AddFlowBalanceConstraints(solver, network, flowVars);\n                AddCapacityConstraints(solver, network, flowVars);\n                AddDemandSatisfactionConstraints(solver, network, flowVars);\n                AddUtilizationBalanceConstraints(solver, network, flowVars, balanceVars, settings);\n                \n                if (settings.EnablePressureConstraints)\n                {\n                    _pressureService.AddPressureConstraints(solver, network, flowVars, pressureVars, settings);\n                }\n\n                if (settings.EnableCompressorStations)\n                {\n                    _compressorService.AddCompressorConstraints(solver, network, flowVars, pressureVars, compressorVars, settings);\n                }\n\n                // Create multi-objective function\n                var objective = CreateBalancedObjective(solver, network, flowVars, balanceVars, settings);\n\n                // Solve the optimization problem\n                var solverStatus = solver.Solve();\n                result.Status = ConvertSolverStatus(solverStatus);\n\n                if (solverStatus == Solver.ResultStatus.OPTIMAL || solverStatus == Solver.ResultStatus.FEASIBLE)\n                {\n                    // Extract results\n                    ExtractFlowResults(result, network, flowVars);\n                    \n                    if (settings.EnablePressureConstraints)\n                    {\n                        ExtractPressureResults(result, network, pressureVars);\n                    }\n\n                    if (settings.EnableCompressorStations)\n                    {\n                        ExtractCompressorResults(result, network, compressorVars);\n                    }\n\n                    // Calculate metrics and costs\n                    CalculateMetrics(result, network);\n                    CalculateCosts(result, network);\n\n                    result.ObjectiveValue = objective.Value();\n                    \n                    var variance = CalculateUtilizationVariance(result);\n                    result.Messages.Add($\"Balanced utilization with variance: {variance:F2}%\");\n                    result.Messages.Add($\"Average utilization: {result.Metrics.AverageCapacityUtilization:F1}%\");\n                }\n                else\n                {\n                    result.Messages.Add($\"Solver failed with status: {solverStatus}\");\n                }\n            }\n            catch (Exception ex)\n            {\n                result.Status = OptimizationStatus.Error;\n                result.Messages.Add($\"Optimization error: {ex.Message}\");\n            }\n\n            result.SolutionTimeMs = (DateTime.Now - startTime).TotalMilliseconds;\n            return result;\n        }\n\n        private string DetermineSolverType(OptimizationSettings settings)\n        {\n            // Balance algorithm may need SCIP for quadratic objective\n            if (settings.EnablePressureConstraints && !settings.UseLinearPressureApproximation)\n            {\n                return \"SCIP\";\n            }\n            return \"SCIP\"; // Prefer SCIP for quadratic balance objectives\n        }\n\n        private void ConfigureSolver(Solver solver, OptimizationSettings settings)\n        {\n            solver.SetTimeLimit((long)(settings.MaxSolutionTimeSeconds * 1000));\n        }\n\n        private Dictionary<string, Variable> CreateFlowVariables(Solver solver, PipelineNetwork network)\n        {\n            var flowVars = new Dictionary<string, Variable>();\n\n            foreach (var segment in network.GetActiveSegments())\n            {\n                var minFlow = segment.GetEffectiveMinFlow();\n                var maxFlow = segment.GetEffectiveCapacity();\n                \n                flowVars[segment.Id] = solver.MakeNumVar(minFlow, maxFlow, $\"flow_{segment.Id}\");\n            }\n\n            return flowVars;\n        }\n\n        private Dictionary<string, Variable> CreatePressureVariables(Solver solver, PipelineNetwork network, OptimizationSettings settings)\n        {\n            var pressureVars = new Dictionary<string, Variable>();\n\n            if (!settings.EnablePressureConstraints)\n                return pressureVars;\n\n            foreach (var point in network.Points.Values.Where(p => p.IsActive))\n            {\n                var minPressureSquared = point.MinPressure * point.MinPressure;\n                var maxPressureSquared = point.MaxPressure * point.MaxPressure;\n                \n                pressureVars[point.Id] = solver.MakeNumVar(minPressureSquared, maxPressureSquared, $\"pressure_sq_{point.Id}\");\n            }\n\n            return pressureVars;\n        }\n\n        private Dictionary<string, Variable> CreateCompressorVariables(Solver solver, PipelineNetwork network, OptimizationSettings settings)\n        {\n            var compressorVars = new Dictionary<string, Variable>();\n\n            if (!settings.EnableCompressorStations)\n                return compressorVars;\n\n            foreach (var compressor in network.GetCompressorStations())\n            {\n                // Binary variable for compressor operation\n                compressorVars[$\"{compressor.Id}_active\"] = solver.MakeBoolVar($\"comp_active_{compressor.Id}\");\n                \n                // Pressure boost variable\n                compressorVars[$\"{compressor.Id}_boost\"] = solver.MakeNumVar(0, compressor.MaxPressureBoost, $\"comp_boost_{compressor.Id}\");\n                \n                // Fuel consumption variable\n                compressorVars[$\"{compressor.Id}_fuel\"] = solver.MakeNumVar(0, double.PositiveInfinity, $\"comp_fuel_{compressor.Id}\");\n            }\n\n            return compressorVars;\n        }\n\n        private Dictionary<string, Variable> CreateBalanceVariables(Solver solver, PipelineNetwork network)\n        {\n            var balanceVars = new Dictionary<string, Variable>();\n\n            // Variables for utilization balance\n            foreach (var segment in network.GetActiveSegments())\n            {\n                balanceVars[$\"util_{segment.Id}\"] = solver.MakeNumVar(0, 100, $\"utilization_{segment.Id}\");\n                balanceVars[$\"util_dev_{segment.Id}\"] = solver.MakeNumVar(-100, 100, $\"util_deviation_{segment.Id}\");\n                balanceVars[$\"util_dev_abs_{segment.Id}\"] = solver.MakeNumVar(0, 100, $\"util_deviation_abs_{segment.Id}\");\n            }\n\n            // Average utilization variable\n            balanceVars[\"avg_util\"] = solver.MakeNumVar(0, 100, \"average_utilization\");\n\n            // Path diversity variables\n            foreach (var receiptPoint in network.GetReceiptPoints())\n            {\n                foreach (var deliveryPoint in network.GetDeliveryPoints())\n                {\n                    balanceVars[$\"path_{receiptPoint.Id}_{deliveryPoint.Id}\"] = solver.MakeBoolVar($\"path_active_{receiptPoint.Id}_{deliveryPoint.Id}\");\n                }\n            }\n\n            return balanceVars;\n        }\n\n        private void AddFlowBalanceConstraints(Solver solver, PipelineNetwork network, Dictionary<string, Variable> flowVars)\n        {\n            foreach (var point in network.Points.Values.Where(p => p.IsActive))\n            {\n                var constraint = solver.MakeConstraint(-double.PositiveInfinity, double.PositiveInfinity, $\"balance_{point.Id}\");\n\n                // Add inflows (positive)\n                foreach (var segment in network.GetIncomingSegments(point.Id))\n                {\n                    constraint.SetCoefficient(flowVars[segment.Id], 1.0);\n                }\n\n                // Add outflows (negative)\n                foreach (var segment in network.GetOutgoingSegments(point.Id))\n                {\n                    constraint.SetCoefficient(flowVars[segment.Id], -1.0);\n                }\n\n                // Set bounds based on point type\n                switch (point.Type)\n                {\n                    case PointType.Receipt:\n                        constraint.SetBounds(-point.SupplyCapacity, 0);\n                        break;\n                    case PointType.Delivery:\n                        constraint.SetBounds(0, point.DemandRequirement);\n                        break;\n                    case PointType.Compressor:\n                        constraint.SetBounds(0, 0);\n                        break;\n                }\n            }\n        }\n\n        private void AddCapacityConstraints(Solver solver, PipelineNetwork network, Dictionary<string, Variable> flowVars)\n        {\n            foreach (var segment in network.GetActiveSegments())\n            {\n                var flowVar = flowVars[segment.Id];\n                \n                solver.MakeConstraint(\n                    segment.GetEffectiveMinFlow(), \n                    segment.GetEffectiveCapacity(), \n                    $\"capacity_{segment.Id}\"\n                ).SetCoefficient(flowVar, 1.0);\n            }\n        }\n\n        private void AddDemandSatisfactionConstraints(Solver solver, PipelineNetwork network, Dictionary<string, Variable> flowVars)\n        {\n            foreach (var deliveryPoint in network.GetDeliveryPoints())\n            {\n                var constraint = solver.MakeConstraint(deliveryPoint.DemandRequirement, deliveryPoint.DemandRequirement, \n                    $\"demand_{deliveryPoint.Id}\");\n\n                foreach (var segment in network.GetIncomingSegments(deliveryPoint.Id))\n                {\n                    constraint.SetCoefficient(flowVars[segment.Id], 1.0);\n                }\n            }\n        }\n\n        private void AddUtilizationBalanceConstraints(Solver solver, PipelineNetwork network, \n            Dictionary<string, Variable> flowVars, Dictionary<string, Variable> balanceVars, OptimizationSettings settings)\n        {\n            var activeSegments = network.GetActiveSegments().ToList();\n            var targetUtilization = GetParameterValue(settings, \"TargetUtilization\", 70.0);\n\n            // Calculate utilization for each segment\n            foreach (var segment in activeSegments)\n            {\n                var utilizationVar = balanceVars[$\"util_{segment.Id}\"];\n                var flowVar = flowVars[segment.Id];\n\n                // utilization = (|flow| / capacity) * 100\n                var utilizationConstraint = solver.MakeConstraint(0, 0, $\"utilization_calc_{segment.Id}\");\n                utilizationConstraint.SetCoefficient(utilizationVar, segment.Capacity);\n                utilizationConstraint.SetCoefficient(flowVar, -100.0); // Simplified linear approximation\n            }\n\n            // Calculate average utilization\n            if (activeSegments.Any())\n            {\n                var avgUtilConstraint = solver.MakeConstraint(0, 0, \"average_utilization_calc\");\n                avgUtilConstraint.SetCoefficient(balanceVars[\"avg_util\"], activeSegments.Count);\n\n                foreach (var segment in activeSegments)\n                {\n                    avgUtilConstraint.SetCoefficient(balanceVars[$\"util_{segment.Id}\"], -1.0);\n                }\n            }\n\n            // Calculate deviations from average\n            foreach (var segment in activeSegments)\n            {\n                var utilizationVar = balanceVars[$\"util_{segment.Id}\"];\n                var deviationVar = balanceVars[$\"util_dev_{segment.Id}\"];\n                var absDeviationVar = balanceVars[$\"util_dev_abs_{segment.Id}\"];\n\n                // deviation = utilization - average_utilization\n                var deviationConstraint = solver.MakeConstraint(0, 0, $\"deviation_calc_{segment.Id}\");\n                deviationConstraint.SetCoefficient(deviationVar, 1.0);\n                deviationConstraint.SetCoefficient(utilizationVar, -1.0);\n                deviationConstraint.SetCoefficient(balanceVars[\"avg_util\"], 1.0);\n\n                // abs_deviation >= deviation\n                solver.MakeConstraint(0, double.PositiveInfinity, $\"abs_dev_pos_{segment.Id}\")\n                    .SetCoefficient(absDeviationVar, 1.0);\n                solver.MakeConstraint(0, double.PositiveInfinity, $\"abs_dev_pos_{segment.Id}\")\n                    .SetCoefficient(deviationVar, -1.0);\n\n                // abs_deviation >= -deviation\n                solver.MakeConstraint(0, double.PositiveInfinity, $\"abs_dev_neg_{segment.Id}\")\n                    .SetCoefficient(absDeviationVar, 1.0);\n                solver.MakeConstraint(0, double.PositiveInfinity, $\"abs_dev_neg_{segment.Id}\")\n                    .SetCoefficient(deviationVar, 1.0);\n            }\n        }\n\n        private Objective CreateBalancedObjective(Solver solver, PipelineNetwork network, \n            Dictionary<string, Variable> flowVars, Dictionary<string, Variable> balanceVars, OptimizationSettings settings)\n        {\n            var objective = solver.Objective();\n            objective.SetMaximization(); // Maximize balance (minimize variance)\n\n            // Get weights\n            var balanceWeight = GetParameterValue(settings, \"BalanceWeight\", 1.0);\n            var throughputWeight = GetParameterValue(settings, \"ThroughputWeight\", 0.5);\n            var costWeight = GetParameterValue(settings, \"CostWeight\", 0.3);\n            var pathDiversityBonus = GetParameterValue(settings, \"PathDiversityBonus\", 0.1);\n\n            // Minimize utilization variance (maximize balance)\n            foreach (var segment in network.GetActiveSegments())\n            {\n                if (balanceVars.TryGetValue($\"util_dev_abs_{segment.Id}\", out var absDeviationVar))\n                {\n                    objective.SetCoefficient(absDeviationVar, -balanceWeight); // Minimize variance\n                }\n            }\n\n            // Maximize total throughput\n            foreach (var receiptPoint in network.GetReceiptPoints())\n            {\n                foreach (var segment in network.GetOutgoingSegments(receiptPoint.Id))\n                {\n                    objective.SetCoefficient(flowVars[segment.Id], throughputWeight);\n                }\n            }\n\n            // Minimize transportation costs\n            foreach (var segment in network.GetActiveSegments())\n            {\n                objective.SetCoefficient(flowVars[segment.Id], -costWeight * segment.TransportationCost);\n            }\n\n            // Bonus for path diversity\n            foreach (var receiptPoint in network.GetReceiptPoints())\n            {\n                foreach (var deliveryPoint in network.GetDeliveryPoints())\n                {\n                    if (balanceVars.TryGetValue($\"path_{receiptPoint.Id}_{deliveryPoint.Id}\", out var pathVar))\n                    {\n                        objective.SetCoefficient(pathVar, pathDiversityBonus);\n                    }\n                }\n            }\n\n            return objective;\n        }\n\n        private double GetParameterValue(OptimizationSettings settings, string paramName, double defaultValue)\n        {\n            if (settings.AlgorithmParameters.TryGetValue(paramName, out var value))\n            {\n                if (value is double doubleValue)\n                    return doubleValue;\n                if (double.TryParse(value.ToString(), out var parsedValue))\n                    return parsedValue;\n            }\n            return defaultValue;\n        }\n\n        private OptimizationStatus ConvertSolverStatus(Solver.ResultStatus status)\n        {\n            return status switch\n            {\n                Solver.ResultStatus.OPTIMAL => OptimizationStatus.Optimal,\n                Solver.ResultStatus.FEASIBLE => OptimizationStatus.Feasible,\n                Solver.ResultStatus.INFEASIBLE => OptimizationStatus.Infeasible,\n                Solver.ResultStatus.UNBOUNDED => OptimizationStatus.Unbounded,\n                _ => OptimizationStatus.Error\n            };\n        }\n\n        private void ExtractFlowResults(OptimizationResult result, PipelineNetwork network, Dictionary<string, Variable> flowVars)\n        {\n            foreach (var segment in network.GetActiveSegments())\n            {\n                var flow = flowVars[segment.Id].SolutionValue();\n                var cost = flow * segment.TransportationCost;\n                \n                result.AddSegmentFlow(segment.Id, flow, segment.Capacity, cost);\n            }\n        }\n\n        private void ExtractPressureResults(OptimizationResult result, PipelineNetwork network, Dictionary<string, Variable> pressureVars)\n        {\n            foreach (var point in network.Points.Values.Where(p => p.IsActive))\n            {\n                if (pressureVars.TryGetValue(point.Id, out var pressureVar))\n                {\n                    var pressureSquared = pressureVar.SolutionValue();\n                    var pressure = Math.Sqrt(Math.Max(0, pressureSquared));\n                    var withinConstraints = pressure >= point.MinPressure && pressure <= point.MaxPressure;\n                    \n                    result.AddPointPressure(point.Id, pressure, pressureSquared, withinConstraints);\n                }\n            }\n        }\n\n        private void ExtractCompressorResults(OptimizationResult result, PipelineNetwork network, Dictionary<string, Variable> compressorVars)\n        {\n            foreach (var compressor in network.GetCompressorStations())\n            {\n                if (result.PointPressures.TryGetValue(compressor.Id, out var pressureResult))\n                {\n                    if (compressorVars.TryGetValue($\"{compressor.Id}_boost\", out var boostVar))\n                    {\n                        pressureResult.PressureBoost = boostVar.SolutionValue();\n                    }\n\n                    if (compressorVars.TryGetValue($\"{compressor.Id}_fuel\", out var fuelVar))\n                    {\n                        pressureResult.FuelConsumption = fuelVar.SolutionValue();\n                    }\n                }\n            }\n        }\n\n        private void CalculateMetrics(OptimizationResult result, PipelineNetwork network)\n        {\n            var metrics = result.Metrics;\n\n            // Calculate total throughput\n            metrics.TotalThroughput = result.SegmentFlows.Values.Where(f => f.Flow > 0).Sum(f => f.Flow);\n\n            // Calculate supply and demand metrics\n            metrics.TotalSupplyUsed = 0;\n            metrics.TotalDemandSatisfied = 0;\n            metrics.TotalDemandRequired = network.GetTotalDemandRequirement();\n\n            foreach (var point in network.Points.Values.Where(p => p.IsActive))\n            {\n                if (point.Type == PointType.Receipt)\n                {\n                    var outflow = network.GetOutgoingSegments(point.Id)\n                        .Where(s => result.SegmentFlows.ContainsKey(s.Id))\n                        .Sum(s => result.SegmentFlows[s.Id].Flow);\n                    metrics.TotalSupplyUsed += outflow;\n                }\n                else if (point.Type == PointType.Delivery)\n                {\n                    var inflow = network.GetIncomingSegments(point.Id)\n                        .Where(s => result.SegmentFlows.ContainsKey(s.Id))\n                        .Sum(s => result.SegmentFlows[s.Id].Flow);\n                    metrics.TotalDemandSatisfied += inflow;\n                }\n            }\n\n            // Calculate utilization metrics\n            var utilizationRates = result.SegmentFlows.Values.Select(f => f.UtilizationPercentage).ToList();\n            metrics.AverageCapacityUtilization = utilizationRates.Any() ? utilizationRates.Average() : 0;\n            metrics.PeakCapacityUtilization = utilizationRates.Any() ? utilizationRates.Max() : 0;\n\n            // Count active elements\n            metrics.ActiveSegments = result.SegmentFlows.Values.Count(f => Math.Abs(f.Flow) > 1e-6);\n            metrics.ActiveCompressors = result.PointPressures.Values.Count(p => p.PressureBoost > 1e-6);\n        }\n\n        private void CalculateCosts(OptimizationResult result, PipelineNetwork network)\n        {\n            var costs = result.TotalCost;\n\n            // Transportation costs\n            costs.TransportationCost = result.SegmentFlows.Values.Sum(f => f.TransportationCost);\n\n            // Fuel and compressor costs\n            costs.FuelCost = result.PointPressures.Values.Sum(p => p.FuelConsumption * 3.50);\n            costs.CompressorCost = result.PointPressures.Values.Where(p => p.PressureBoost > 0).Sum(p => p.PressureBoost * 0.01);\n        }\n\n        private double CalculateUtilizationVariance(OptimizationResult result)\n        {\n            var utilizationRates = result.SegmentFlows.Values.Select(f => f.UtilizationPercentage).ToList();\n            \n            if (!utilizationRates.Any())\n                return 0;\n\n            var mean = utilizationRates.Average();\n            var variance = utilizationRates.Sum(u => Math.Pow(u - mean, 2)) / utilizationRates.Count;\n            \n            return Math.Sqrt(variance);\n        }\n    }\n}\n","size_bytes":24130},"Algorithms/IOptimizationAlgorithm.cs":{"content":"using GasPipelineOptimization.Models;\n\nnamespace GasPipelineOptimization.Algorithms\n{\n    /// <summary>\n    /// Interface for all optimization algorithms\n    /// </summary>\n    public interface IOptimizationAlgorithm\n    {\n        /// <summary>\n        /// Name of the optimization algorithm\n        /// </summary>\n        string Name { get; }\n\n        /// <summary>\n        /// Description of what the algorithm optimizes for\n        /// </summary>\n        string Description { get; }\n\n        /// <summary>\n        /// Executes the optimization algorithm\n        /// </summary>\n        /// <param name=\"network\">The pipeline network to optimize</param>\n        /// <param name=\"settings\">Optimization settings and constraints</param>\n        /// <returns>Optimization result</returns>\n        OptimizationResult Optimize(PipelineNetwork network, OptimizationSettings settings);\n\n        /// <summary>\n        /// Validates if the algorithm can handle the given network and settings\n        /// </summary>\n        /// <param name=\"network\">The pipeline network</param>\n        /// <param name=\"settings\">Optimization settings</param>\n        /// <returns>True if algorithm is applicable, false otherwise</returns>\n        bool CanHandle(PipelineNetwork network, OptimizationSettings settings);\n\n        /// <summary>\n        /// Gets algorithm-specific parameters and their descriptions\n        /// </summary>\n        Dictionary<string, string> GetParameters();\n    }\n}\n","size_bytes":1471},"Algorithms/MaximizeThroughputAlgorithm.cs":{"content":"using Google.OrTools.LinearSolver;\nusing GasPipelineOptimization.Models;\nusing GasPipelineOptimization.Services;\n\nnamespace GasPipelineOptimization.Algorithms\n{\n    /// <summary>\n    /// Algorithm to maximize total throughput in the gas pipeline network\n    /// </summary>\n    public class MaximizeThroughputAlgorithm : IOptimizationAlgorithm\n    {\n        public string Name => \"Maximize Throughput\";\n        public string Description => \"Maximizes the total gas flow through the pipeline network while respecting capacity and pressure constraints\";\n\n        private readonly PressureConstraintService _pressureService;\n        private readonly CompressorService _compressorService;\n\n        public MaximizeThroughputAlgorithm()\n        {\n            _pressureService = new PressureConstraintService();\n            _compressorService = new CompressorService();\n        }\n\n        public bool CanHandle(PipelineNetwork network, OptimizationSettings settings)\n        {\n            // This algorithm can handle any valid network\n            return network.IsValid(out _);\n        }\n\n        public Dictionary<string, string> GetParameters()\n        {\n            return new Dictionary<string, string>\n            {\n                { \"ThroughputWeight\", \"Weight for throughput maximization objective (default: 1.0)\" },\n                { \"DemandPriority\", \"Priority for satisfying demand vs maximizing total flow (default: 1.0)\" },\n                { \"SupplyUtilization\", \"Target supply utilization percentage (default: 100)\" }\n            };\n        }\n\n        public OptimizationResult Optimize(PipelineNetwork network, OptimizationSettings settings)\n        {\n            var startTime = DateTime.Now;\n            var result = new OptimizationResult\n            {\n                AlgorithmUsed = Name,\n                Status = OptimizationStatus.NotSolved\n            };\n\n            try\n            {\n                // Determine solver type based on constraints\n                var solverType = DetermineSolverType(settings);\n                result.SolverUsed = solverType;\n\n                using var solver = Solver.CreateSolver(solverType);\n                if (solver == null)\n                {\n                    result.Status = OptimizationStatus.Error;\n                    result.Messages.Add($\"Failed to create {solverType} solver\");\n                    return result;\n                }\n\n                // Set solver parameters\n                ConfigureSolver(solver, settings);\n\n                // Create decision variables\n                var flowVars = CreateFlowVariables(solver, network);\n                var pressureVars = CreatePressureVariables(solver, network, settings);\n                var compressorVars = CreateCompressorVariables(solver, network, settings);\n\n                // Add constraints\n                AddFlowBalanceConstraints(solver, network, flowVars);\n                AddCapacityConstraints(solver, network, flowVars);\n                \n                if (settings.EnablePressureConstraints)\n                {\n                    _pressureService.AddPressureConstraints(solver, network, flowVars, pressureVars, settings);\n                }\n\n                if (settings.EnableCompressorStations)\n                {\n                    _compressorService.AddCompressorConstraints(solver, network, flowVars, pressureVars, compressorVars, settings);\n                }\n\n                // Create objective function to maximize throughput\n                var objective = CreateThroughputObjective(solver, network, flowVars, settings);\n\n                // Solve the optimization problem\n                var solverStatus = solver.Solve();\n                result.Status = ConvertSolverStatus(solverStatus);\n\n                if (solverStatus == Solver.ResultStatus.OPTIMAL || solverStatus == Solver.ResultStatus.FEASIBLE)\n                {\n                    // Extract results\n                    ExtractFlowResults(result, network, flowVars);\n                    \n                    if (settings.EnablePressureConstraints)\n                    {\n                        ExtractPressureResults(result, network, pressureVars);\n                    }\n\n                    if (settings.EnableCompressorStations)\n                    {\n                        ExtractCompressorResults(result, network, compressorVars);\n                    }\n\n                    // Calculate metrics and costs\n                    CalculateMetrics(result, network);\n                    CalculateCosts(result, network);\n\n                    result.ObjectiveValue = objective.Value();\n                    result.Messages.Add($\"Maximized throughput: {result.Metrics.TotalThroughput:F2} MMscfd\");\n                }\n                else\n                {\n                    result.Messages.Add($\"Solver failed with status: {solverStatus}\");\n                }\n            }\n            catch (Exception ex)\n            {\n                result.Status = OptimizationStatus.Error;\n                result.Messages.Add($\"Optimization error: {ex.Message}\");\n            }\n\n            result.SolutionTimeMs = (DateTime.Now - startTime).TotalMilliseconds;\n            return result;\n        }\n\n        private string DetermineSolverType(OptimizationSettings settings)\n        {\n            // Use SCIP for nonlinear pressure constraints, GLOP for linear problems\n            if (settings.EnablePressureConstraints && !settings.UseLinearPressureApproximation)\n            {\n                return \"SCIP\";\n            }\n            return settings.PreferredSolver;\n        }\n\n        private void ConfigureSolver(Solver solver, OptimizationSettings settings)\n        {\n            solver.SetTimeLimit((long)(settings.MaxSolutionTimeSeconds * 1000));\n            \n            if (solver.SolverVersion().Contains(\"GLOP\"))\n            {\n                solver.SetSolverSpecificParametersAsString($\"solution_feasibility_tolerance:{settings.FeasibilityTolerance}\");\n            }\n        }\n\n        private Dictionary<string, Variable> CreateFlowVariables(Solver solver, PipelineNetwork network)\n        {\n            var flowVars = new Dictionary<string, Variable>();\n\n            foreach (var segment in network.GetActiveSegments())\n            {\n                var minFlow = segment.GetEffectiveMinFlow();\n                var maxFlow = segment.GetEffectiveCapacity();\n                \n                flowVars[segment.Id] = solver.MakeNumVar(minFlow, maxFlow, $\"flow_{segment.Id}\");\n            }\n\n            return flowVars;\n        }\n\n        private Dictionary<string, Variable> CreatePressureVariables(Solver solver, PipelineNetwork network, OptimizationSettings settings)\n        {\n            var pressureVars = new Dictionary<string, Variable>();\n\n            if (!settings.EnablePressureConstraints)\n                return pressureVars;\n\n            foreach (var point in network.Points.Values.Where(p => p.IsActive))\n            {\n                var minPressureSquared = point.MinPressure * point.MinPressure;\n                var maxPressureSquared = point.MaxPressure * point.MaxPressure;\n                \n                pressureVars[point.Id] = solver.MakeNumVar(minPressureSquared, maxPressureSquared, $\"pressure_sq_{point.Id}\");\n            }\n\n            return pressureVars;\n        }\n\n        private Dictionary<string, Variable> CreateCompressorVariables(Solver solver, PipelineNetwork network, OptimizationSettings settings)\n        {\n            var compressorVars = new Dictionary<string, Variable>();\n\n            if (!settings.EnableCompressorStations)\n                return compressorVars;\n\n            foreach (var compressor in network.GetCompressorStations())\n            {\n                // Binary variable for compressor operation\n                compressorVars[$\"{compressor.Id}_active\"] = solver.MakeBoolVar($\"comp_active_{compressor.Id}\");\n                \n                // Pressure boost variable\n                compressorVars[$\"{compressor.Id}_boost\"] = solver.MakeNumVar(0, compressor.MaxPressureBoost, $\"comp_boost_{compressor.Id}\");\n                \n                // Fuel consumption variable\n                compressorVars[$\"{compressor.Id}_fuel\"] = solver.MakeNumVar(0, double.PositiveInfinity, $\"comp_fuel_{compressor.Id}\");\n            }\n\n            return compressorVars;\n        }\n\n        private void AddFlowBalanceConstraints(Solver solver, PipelineNetwork network, Dictionary<string, Variable> flowVars)\n        {\n            foreach (var point in network.Points.Values.Where(p => p.IsActive))\n            {\n                var constraint = solver.MakeConstraint(-double.PositiveInfinity, double.PositiveInfinity, $\"balance_{point.Id}\");\n\n                // Add inflows (positive)\n                foreach (var segment in network.GetIncomingSegments(point.Id))\n                {\n                    constraint.SetCoefficient(flowVars[segment.Id], 1.0);\n                }\n\n                // Add outflows (negative)\n                foreach (var segment in network.GetOutgoingSegments(point.Id))\n                {\n                    constraint.SetCoefficient(flowVars[segment.Id], -1.0);\n                }\n\n                // Set bounds based on point type\n                switch (point.Type)\n                {\n                    case PointType.Receipt:\n                        constraint.SetBounds(-point.SupplyCapacity, 0); // Can supply up to capacity\n                        break;\n                    case PointType.Delivery:\n                        constraint.SetBounds(0, point.DemandRequirement); // Can satisfy up to demand requirement\n                        break;\n                    case PointType.Compressor:\n                        constraint.SetBounds(0, 0); // Flow balance at compressor\n                        break;\n                }\n            }\n        }\n\n        private void AddCapacityConstraints(Solver solver, PipelineNetwork network, Dictionary<string, Variable> flowVars)\n        {\n            foreach (var segment in network.GetActiveSegments())\n            {\n                var flowVar = flowVars[segment.Id];\n                \n                // Flow must be within segment capacity limits\n                solver.MakeConstraint(\n                    segment.GetEffectiveMinFlow(), \n                    segment.GetEffectiveCapacity(), \n                    $\"capacity_{segment.Id}\"\n                ).SetCoefficient(flowVar, 1.0);\n            }\n        }\n\n        private Objective CreateThroughputObjective(Solver solver, PipelineNetwork network, \n            Dictionary<string, Variable> flowVars, OptimizationSettings settings)\n        {\n            var objective = solver.Objective();\n            objective.SetMaximization();\n\n            // Get algorithm-specific parameters\n            var throughputWeight = GetParameterValue(settings, \"ThroughputWeight\", 1.0);\n            var demandPriority = GetParameterValue(settings, \"DemandPriority\", 1.0);\n\n            // Maximize total throughput through receipt points\n            foreach (var receiptPoint in network.GetReceiptPoints())\n            {\n                foreach (var segment in network.GetOutgoingSegments(receiptPoint.Id))\n                {\n                    objective.SetCoefficient(flowVars[segment.Id], throughputWeight);\n                }\n            }\n\n            // Add higher weight for satisfying demand\n            foreach (var deliveryPoint in network.GetDeliveryPoints())\n            {\n                foreach (var segment in network.GetIncomingSegments(deliveryPoint.Id))\n                {\n                    objective.SetCoefficient(flowVars[segment.Id], demandPriority);\n                }\n            }\n\n            return objective;\n        }\n\n        private double GetParameterValue(OptimizationSettings settings, string paramName, double defaultValue)\n        {\n            if (settings.AlgorithmParameters.TryGetValue(paramName, out var value))\n            {\n                if (value is double doubleValue)\n                    return doubleValue;\n                if (double.TryParse(value.ToString(), out var parsedValue))\n                    return parsedValue;\n            }\n            return defaultValue;\n        }\n\n        private OptimizationStatus ConvertSolverStatus(Solver.ResultStatus status)\n        {\n            return status switch\n            {\n                Solver.ResultStatus.OPTIMAL => OptimizationStatus.Optimal,\n                Solver.ResultStatus.FEASIBLE => OptimizationStatus.Feasible,\n                Solver.ResultStatus.INFEASIBLE => OptimizationStatus.Infeasible,\n                Solver.ResultStatus.UNBOUNDED => OptimizationStatus.Unbounded,\n                _ => OptimizationStatus.Error\n            };\n        }\n\n        private void ExtractFlowResults(OptimizationResult result, PipelineNetwork network, Dictionary<string, Variable> flowVars)\n        {\n            foreach (var segment in network.GetActiveSegments())\n            {\n                var flow = flowVars[segment.Id].SolutionValue();\n                var cost = flow * segment.TransportationCost;\n                \n                result.AddSegmentFlow(segment.Id, flow, segment.Capacity, cost);\n            }\n        }\n\n        private void ExtractPressureResults(OptimizationResult result, PipelineNetwork network, Dictionary<string, Variable> pressureVars)\n        {\n            foreach (var point in network.Points.Values.Where(p => p.IsActive))\n            {\n                if (pressureVars.TryGetValue(point.Id, out var pressureVar))\n                {\n                    var pressureSquared = pressureVar.SolutionValue();\n                    var pressure = Math.Sqrt(Math.Max(0, pressureSquared));\n                    var withinConstraints = pressure >= point.MinPressure && pressure <= point.MaxPressure;\n                    \n                    result.AddPointPressure(point.Id, pressure, pressureSquared, withinConstraints);\n                }\n            }\n        }\n\n        private void ExtractCompressorResults(OptimizationResult result, PipelineNetwork network, Dictionary<string, Variable> compressorVars)\n        {\n            foreach (var compressor in network.GetCompressorStations())\n            {\n                if (result.PointPressures.TryGetValue(compressor.Id, out var pressureResult))\n                {\n                    if (compressorVars.TryGetValue($\"{compressor.Id}_boost\", out var boostVar))\n                    {\n                        pressureResult.PressureBoost = boostVar.SolutionValue();\n                    }\n\n                    if (compressorVars.TryGetValue($\"{compressor.Id}_fuel\", out var fuelVar))\n                    {\n                        pressureResult.FuelConsumption = fuelVar.SolutionValue();\n                    }\n                }\n            }\n        }\n\n        private void CalculateMetrics(OptimizationResult result, PipelineNetwork network)\n        {\n            var metrics = result.Metrics;\n\n            // Calculate total throughput\n            metrics.TotalThroughput = result.SegmentFlows.Values.Where(f => f.Flow > 0).Sum(f => f.Flow);\n\n            // Calculate supply and demand metrics\n            metrics.TotalSupplyUsed = 0;\n            metrics.TotalDemandSatisfied = 0;\n            metrics.TotalDemandRequired = network.GetTotalDemandRequirement();\n\n            foreach (var point in network.Points.Values.Where(p => p.IsActive))\n            {\n                if (point.Type == PointType.Receipt)\n                {\n                    var outflow = network.GetOutgoingSegments(point.Id)\n                        .Where(s => result.SegmentFlows.ContainsKey(s.Id))\n                        .Sum(s => result.SegmentFlows[s.Id].Flow);\n                    metrics.TotalSupplyUsed += outflow;\n                }\n                else if (point.Type == PointType.Delivery)\n                {\n                    var inflow = network.GetIncomingSegments(point.Id)\n                        .Where(s => result.SegmentFlows.ContainsKey(s.Id))\n                        .Sum(s => result.SegmentFlows[s.Id].Flow);\n                    metrics.TotalDemandSatisfied += inflow;\n                }\n            }\n\n            // Calculate utilization metrics\n            var utilizationRates = result.SegmentFlows.Values.Select(f => f.UtilizationPercentage).ToList();\n            metrics.AverageCapacityUtilization = utilizationRates.Any() ? utilizationRates.Average() : 0;\n            metrics.PeakCapacityUtilization = utilizationRates.Any() ? utilizationRates.Max() : 0;\n\n            // Count active elements\n            metrics.ActiveSegments = result.SegmentFlows.Values.Count(f => Math.Abs(f.Flow) > 1e-6);\n            metrics.ActiveCompressors = result.PointPressures.Values.Count(p => p.PressureBoost > 1e-6);\n        }\n\n        private void CalculateCosts(OptimizationResult result, PipelineNetwork network)\n        {\n            var costs = result.TotalCost;\n\n            // Transportation costs\n            costs.TransportationCost = result.SegmentFlows.Values.Sum(f => f.TransportationCost);\n\n            // Fuel and compressor costs\n            costs.FuelCost = result.PointPressures.Values.Sum(p => p.FuelConsumption * 3.50); // Assume $3.50/MMscf fuel cost\n            costs.CompressorCost = result.PointPressures.Values.Where(p => p.PressureBoost > 0).Sum(p => p.PressureBoost * 0.01); // $0.01 per psi boost\n        }\n    }\n}\n","size_bytes":17346},"Algorithms/MinimizeCostAlgorithm.cs":{"content":"using Google.OrTools.LinearSolver;\nusing GasPipelineOptimization.Models;\nusing GasPipelineOptimization.Services;\n\nnamespace GasPipelineOptimization.Algorithms\n{\n    /// <summary>\n    /// Algorithm to minimize total cost while satisfying demand requirements\n    /// </summary>\n    public class MinimizeCostAlgorithm : IOptimizationAlgorithm\n    {\n        public string Name => \"Minimize Cost\";\n        public string Description => \"Minimizes total operational costs including transportation, fuel, and compression costs while satisfying all demand requirements\";\n\n        private readonly PressureConstraintService _pressureService;\n        private readonly CompressorService _compressorService;\n\n        public MinimizeCostAlgorithm()\n        {\n            _pressureService = new PressureConstraintService();\n            _compressorService = new CompressorService();\n        }\n\n        public bool CanHandle(PipelineNetwork network, OptimizationSettings settings)\n        {\n            // This algorithm can handle any valid network\n            return network.IsValid(out _);\n        }\n\n        public Dictionary<string, string> GetParameters()\n        {\n            return new Dictionary<string, string>\n            {\n                { \"FuelCostPerMMscf\", \"Cost of fuel per MMscf (default: 3.50)\" },\n                { \"CompressorOperatingCost\", \"Cost per psi of compression (default: 0.01)\" },\n                { \"TransportationWeight\", \"Weight for transportation costs (default: 1.0)\" },\n                { \"FuelWeight\", \"Weight for fuel costs (default: 1.0)\" },\n                { \"CompressorWeight\", \"Weight for compressor costs (default: 1.0)\" }\n            };\n        }\n\n        public OptimizationResult Optimize(PipelineNetwork network, OptimizationSettings settings)\n        {\n            var startTime = DateTime.Now;\n            var result = new OptimizationResult\n            {\n                AlgorithmUsed = Name,\n                Status = OptimizationStatus.NotSolved\n            };\n\n            try\n            {\n                // Determine solver type based on constraints\n                var solverType = DetermineSolverType(settings);\n                result.SolverUsed = solverType;\n\n                using var solver = Solver.CreateSolver(solverType);\n                if (solver == null)\n                {\n                    result.Status = OptimizationStatus.Error;\n                    result.Messages.Add($\"Failed to create {solverType} solver\");\n                    return result;\n                }\n\n                // Set solver parameters\n                ConfigureSolver(solver, settings);\n\n                // Create decision variables\n                var flowVars = CreateFlowVariables(solver, network);\n                var pressureVars = CreatePressureVariables(solver, network, settings);\n                var compressorVars = CreateCompressorVariables(solver, network, settings);\n                var costVars = CreateCostVariables(solver, network, settings);\n\n                // Add constraints\n                AddFlowBalanceConstraints(solver, network, flowVars);\n                AddCapacityConstraints(solver, network, flowVars);\n                AddDemandSatisfactionConstraints(solver, network, flowVars);\n                \n                if (settings.EnablePressureConstraints)\n                {\n                    _pressureService.AddPressureConstraints(solver, network, flowVars, pressureVars, settings);\n                }\n\n                if (settings.EnableCompressorStations)\n                {\n                    _compressorService.AddCompressorConstraints(solver, network, flowVars, pressureVars, compressorVars, settings);\n                }\n\n                // Add cost calculation constraints\n                AddCostCalculationConstraints(solver, network, flowVars, compressorVars, costVars, settings);\n\n                // Create objective function to minimize total cost\n                var objective = CreateCostMinimizationObjective(solver, costVars, settings);\n\n                // Solve the optimization problem\n                var solverStatus = solver.Solve();\n                result.Status = ConvertSolverStatus(solverStatus);\n\n                if (solverStatus == Solver.ResultStatus.OPTIMAL || solverStatus == Solver.ResultStatus.FEASIBLE)\n                {\n                    // Extract results\n                    ExtractFlowResults(result, network, flowVars);\n                    \n                    if (settings.EnablePressureConstraints)\n                    {\n                        ExtractPressureResults(result, network, pressureVars);\n                    }\n\n                    if (settings.EnableCompressorStations)\n                    {\n                        ExtractCompressorResults(result, network, compressorVars);\n                    }\n\n                    // Calculate metrics and costs\n                    CalculateMetrics(result, network);\n                    CalculateCosts(result, network, settings);\n\n                    result.ObjectiveValue = objective.Value();\n                    result.Messages.Add($\"Minimized total cost: ${result.TotalCost.TotalCost:F2}\");\n                }\n                else\n                {\n                    result.Messages.Add($\"Solver failed with status: {solverStatus}\");\n                }\n            }\n            catch (Exception ex)\n            {\n                result.Status = OptimizationStatus.Error;\n                result.Messages.Add($\"Optimization error: {ex.Message}\");\n            }\n\n            result.SolutionTimeMs = (DateTime.Now - startTime).TotalMilliseconds;\n            return result;\n        }\n\n        private string DetermineSolverType(OptimizationSettings settings)\n        {\n            // Use SCIP for nonlinear pressure constraints, GLOP for linear problems\n            if (settings.EnablePressureConstraints && !settings.UseLinearPressureApproximation)\n            {\n                return \"SCIP\";\n            }\n            return settings.PreferredSolver;\n        }\n\n        private void ConfigureSolver(Solver solver, OptimizationSettings settings)\n        {\n            solver.SetTimeLimit((long)(settings.MaxSolutionTimeSeconds * 1000));\n            \n            if (solver.SolverVersion().Contains(\"GLOP\"))\n            {\n                solver.SetSolverSpecificParametersAsString($\"solution_feasibility_tolerance:{settings.FeasibilityTolerance}\");\n            }\n        }\n\n        private Dictionary<string, Variable> CreateFlowVariables(Solver solver, PipelineNetwork network)\n        {\n            var flowVars = new Dictionary<string, Variable>();\n\n            foreach (var segment in network.GetActiveSegments())\n            {\n                var minFlow = segment.GetEffectiveMinFlow();\n                var maxFlow = segment.GetEffectiveCapacity();\n                \n                flowVars[segment.Id] = solver.MakeNumVar(minFlow, maxFlow, $\"flow_{segment.Id}\");\n            }\n\n            return flowVars;\n        }\n\n        private Dictionary<string, Variable> CreatePressureVariables(Solver solver, PipelineNetwork network, OptimizationSettings settings)\n        {\n            var pressureVars = new Dictionary<string, Variable>();\n\n            if (!settings.EnablePressureConstraints)\n                return pressureVars;\n\n            foreach (var point in network.Points.Values.Where(p => p.IsActive))\n            {\n                var minPressureSquared = point.MinPressure * point.MinPressure;\n                var maxPressureSquared = point.MaxPressure * point.MaxPressure;\n                \n                pressureVars[point.Id] = solver.MakeNumVar(minPressureSquared, maxPressureSquared, $\"pressure_sq_{point.Id}\");\n            }\n\n            return pressureVars;\n        }\n\n        private Dictionary<string, Variable> CreateCompressorVariables(Solver solver, PipelineNetwork network, OptimizationSettings settings)\n        {\n            var compressorVars = new Dictionary<string, Variable>();\n\n            if (!settings.EnableCompressorStations)\n                return compressorVars;\n\n            foreach (var compressor in network.GetCompressorStations())\n            {\n                // Binary variable for compressor operation\n                compressorVars[$\"{compressor.Id}_active\"] = solver.MakeBoolVar($\"comp_active_{compressor.Id}\");\n                \n                // Pressure boost variable\n                compressorVars[$\"{compressor.Id}_boost\"] = solver.MakeNumVar(0, compressor.MaxPressureBoost, $\"comp_boost_{compressor.Id}\");\n                \n                // Fuel consumption variable\n                compressorVars[$\"{compressor.Id}_fuel\"] = solver.MakeNumVar(0, double.PositiveInfinity, $\"comp_fuel_{compressor.Id}\");\n            }\n\n            return compressorVars;\n        }\n\n        private Dictionary<string, Variable> CreateCostVariables(Solver solver, PipelineNetwork network, OptimizationSettings settings)\n        {\n            var costVars = new Dictionary<string, Variable>();\n\n            // Transportation cost variables\n            foreach (var segment in network.GetActiveSegments())\n            {\n                costVars[$\"transport_{segment.Id}\"] = solver.MakeNumVar(0, double.PositiveInfinity, $\"transport_cost_{segment.Id}\");\n            }\n\n            // Fuel cost variables\n            if (settings.EnableCompressorStations)\n            {\n                foreach (var compressor in network.GetCompressorStations())\n                {\n                    costVars[$\"fuel_{compressor.Id}\"] = solver.MakeNumVar(0, double.PositiveInfinity, $\"fuel_cost_{compressor.Id}\");\n                    costVars[$\"compressor_{compressor.Id}\"] = solver.MakeNumVar(0, double.PositiveInfinity, $\"compressor_cost_{compressor.Id}\");\n                }\n            }\n\n            // Total cost variable\n            costVars[\"total\"] = solver.MakeNumVar(0, double.PositiveInfinity, \"total_cost\");\n\n            return costVars;\n        }\n\n        private void AddFlowBalanceConstraints(Solver solver, PipelineNetwork network, Dictionary<string, Variable> flowVars)\n        {\n            foreach (var point in network.Points.Values.Where(p => p.IsActive))\n            {\n                var constraint = solver.MakeConstraint(-double.PositiveInfinity, double.PositiveInfinity, $\"balance_{point.Id}\");\n\n                // Add inflows (positive)\n                foreach (var segment in network.GetIncomingSegments(point.Id))\n                {\n                    constraint.SetCoefficient(flowVars[segment.Id], 1.0);\n                }\n\n                // Add outflows (negative)\n                foreach (var segment in network.GetOutgoingSegments(point.Id))\n                {\n                    constraint.SetCoefficient(flowVars[segment.Id], -1.0);\n                }\n\n                // Set bounds based on point type\n                switch (point.Type)\n                {\n                    case PointType.Receipt:\n                        constraint.SetBounds(-point.SupplyCapacity, 0); // Can supply up to capacity\n                        break;\n                    case PointType.Delivery:\n                        constraint.SetBounds(0, point.DemandRequirement); // Can satisfy up to demand requirement\n                        break;\n                    case PointType.Compressor:\n                        constraint.SetBounds(0, 0); // Flow balance at compressor\n                        break;\n                }\n            }\n        }\n\n        private void AddCapacityConstraints(Solver solver, PipelineNetwork network, Dictionary<string, Variable> flowVars)\n        {\n            foreach (var segment in network.GetActiveSegments())\n            {\n                var flowVar = flowVars[segment.Id];\n                \n                // Flow must be within segment capacity limits\n                solver.MakeConstraint(\n                    segment.GetEffectiveMinFlow(), \n                    segment.GetEffectiveCapacity(), \n                    $\"capacity_{segment.Id}\"\n                ).SetCoefficient(flowVar, 1.0);\n            }\n        }\n\n        private void AddDemandSatisfactionConstraints(Solver solver, PipelineNetwork network, Dictionary<string, Variable> flowVars)\n        {\n            // Ensure all delivery point demands are satisfied exactly\n            foreach (var deliveryPoint in network.GetDeliveryPoints())\n            {\n                var constraint = solver.MakeConstraint(deliveryPoint.DemandRequirement, deliveryPoint.DemandRequirement, \n                    $\"demand_{deliveryPoint.Id}\");\n\n                foreach (var segment in network.GetIncomingSegments(deliveryPoint.Id))\n                {\n                    constraint.SetCoefficient(flowVars[segment.Id], 1.0);\n                }\n            }\n        }\n\n        private void AddCostCalculationConstraints(Solver solver, PipelineNetwork network, \n            Dictionary<string, Variable> flowVars, Dictionary<string, Variable> compressorVars, \n            Dictionary<string, Variable> costVars, OptimizationSettings settings)\n        {\n            // Transportation cost constraints\n            foreach (var segment in network.GetActiveSegments())\n            {\n                var transportCostVar = costVars[$\"transport_{segment.Id}\"];\n                var flowVar = flowVars[segment.Id];\n                \n                // Linear approximation: transport_cost = flow * unit_cost\n                var constraint = solver.MakeConstraint(0, 0, $\"transport_cost_{segment.Id}\");\n                constraint.SetCoefficient(transportCostVar, 1.0);\n                constraint.SetCoefficient(flowVar, -segment.TransportationCost);\n            }\n\n            // Fuel and compressor cost constraints\n            if (settings.EnableCompressorStations)\n            {\n                var fuelCost = GetParameterValue(settings, \"FuelCostPerMMscf\", 3.50);\n                var compressorCost = GetParameterValue(settings, \"CompressorOperatingCost\", 0.01);\n\n                foreach (var compressor in network.GetCompressorStations())\n                {\n                    if (compressorVars.TryGetValue($\"{compressor.Id}_fuel\", out var fuelVar) &&\n                        costVars.TryGetValue($\"fuel_{compressor.Id}\", out var fuelCostVar))\n                    {\n                        // fuel_cost = fuel_consumption * fuel_price\n                        var fuelConstraint = solver.MakeConstraint(0, 0, $\"fuel_cost_{compressor.Id}\");\n                        fuelConstraint.SetCoefficient(fuelCostVar, 1.0);\n                        fuelConstraint.SetCoefficient(fuelVar, -fuelCost);\n                    }\n\n                    if (compressorVars.TryGetValue($\"{compressor.Id}_boost\", out var boostVar) &&\n                        costVars.TryGetValue($\"compressor_{compressor.Id}\", out var compCostVar))\n                    {\n                        // compressor_cost = pressure_boost * operating_cost\n                        var compConstraint = solver.MakeConstraint(0, 0, $\"compressor_cost_{compressor.Id}\");\n                        compConstraint.SetCoefficient(compCostVar, 1.0);\n                        compConstraint.SetCoefficient(boostVar, -compressorCost);\n                    }\n                }\n            }\n\n            // Total cost constraint\n            var totalCostConstraint = solver.MakeConstraint(0, 0, \"total_cost_calculation\");\n            totalCostConstraint.SetCoefficient(costVars[\"total\"], 1.0);\n\n            // Add transportation costs\n            foreach (var segment in network.GetActiveSegments())\n            {\n                totalCostConstraint.SetCoefficient(costVars[$\"transport_{segment.Id}\"], -1.0);\n            }\n\n            // Add fuel and compressor costs\n            if (settings.EnableCompressorStations)\n            {\n                foreach (var compressor in network.GetCompressorStations())\n                {\n                    if (costVars.TryGetValue($\"fuel_{compressor.Id}\", out var fuelCostVar))\n                    {\n                        totalCostConstraint.SetCoefficient(fuelCostVar, -1.0);\n                    }\n                    if (costVars.TryGetValue($\"compressor_{compressor.Id}\", out var compCostVar))\n                    {\n                        totalCostConstraint.SetCoefficient(compCostVar, -1.0);\n                    }\n                }\n            }\n        }\n\n        private Objective CreateCostMinimizationObjective(Solver solver, Dictionary<string, Variable> costVars, OptimizationSettings settings)\n        {\n            var objective = solver.Objective();\n            objective.SetMinimization();\n\n            // Get weights for different cost components\n            var transportWeight = GetParameterValue(settings, \"TransportationWeight\", 1.0);\n            var fuelWeight = GetParameterValue(settings, \"FuelWeight\", 1.0);\n            var compressorWeight = GetParameterValue(settings, \"CompressorWeight\", 1.0);\n\n            // Minimize total cost with component weights\n            objective.SetCoefficient(costVars[\"total\"], 1.0);\n\n            return objective;\n        }\n\n        private double GetParameterValue(OptimizationSettings settings, string paramName, double defaultValue)\n        {\n            if (settings.AlgorithmParameters.TryGetValue(paramName, out var value))\n            {\n                if (value is double doubleValue)\n                    return doubleValue;\n                if (double.TryParse(value.ToString(), out var parsedValue))\n                    return parsedValue;\n            }\n            return defaultValue;\n        }\n\n        private OptimizationStatus ConvertSolverStatus(Solver.ResultStatus status)\n        {\n            return status switch\n            {\n                Solver.ResultStatus.OPTIMAL => OptimizationStatus.Optimal,\n                Solver.ResultStatus.FEASIBLE => OptimizationStatus.Feasible,\n                Solver.ResultStatus.INFEASIBLE => OptimizationStatus.Infeasible,\n                Solver.ResultStatus.UNBOUNDED => OptimizationStatus.Unbounded,\n                _ => OptimizationStatus.Error\n            };\n        }\n\n        private void ExtractFlowResults(OptimizationResult result, PipelineNetwork network, Dictionary<string, Variable> flowVars)\n        {\n            foreach (var segment in network.GetActiveSegments())\n            {\n                var flow = flowVars[segment.Id].SolutionValue();\n                var cost = flow * segment.TransportationCost;\n                \n                result.AddSegmentFlow(segment.Id, flow, segment.Capacity, cost);\n            }\n        }\n\n        private void ExtractPressureResults(OptimizationResult result, PipelineNetwork network, Dictionary<string, Variable> pressureVars)\n        {\n            foreach (var point in network.Points.Values.Where(p => p.IsActive))\n            {\n                if (pressureVars.TryGetValue(point.Id, out var pressureVar))\n                {\n                    var pressureSquared = pressureVar.SolutionValue();\n                    var pressure = Math.Sqrt(Math.Max(0, pressureSquared));\n                    var withinConstraints = pressure >= point.MinPressure && pressure <= point.MaxPressure;\n                    \n                    result.AddPointPressure(point.Id, pressure, pressureSquared, withinConstraints);\n                }\n            }\n        }\n\n        private void ExtractCompressorResults(OptimizationResult result, PipelineNetwork network, Dictionary<string, Variable> compressorVars)\n        {\n            foreach (var compressor in network.GetCompressorStations())\n            {\n                if (result.PointPressures.TryGetValue(compressor.Id, out var pressureResult))\n                {\n                    if (compressorVars.TryGetValue($\"{compressor.Id}_boost\", out var boostVar))\n                    {\n                        pressureResult.PressureBoost = boostVar.SolutionValue();\n                    }\n\n                    if (compressorVars.TryGetValue($\"{compressor.Id}_fuel\", out var fuelVar))\n                    {\n                        pressureResult.FuelConsumption = fuelVar.SolutionValue();\n                    }\n                }\n            }\n        }\n\n        private void CalculateMetrics(OptimizationResult result, PipelineNetwork network)\n        {\n            var metrics = result.Metrics;\n\n            // Calculate total throughput\n            metrics.TotalThroughput = result.SegmentFlows.Values.Where(f => f.Flow > 0).Sum(f => f.Flow);\n\n            // Calculate supply and demand metrics\n            metrics.TotalSupplyUsed = 0;\n            metrics.TotalDemandSatisfied = 0;\n            metrics.TotalDemandRequired = network.GetTotalDemandRequirement();\n\n            foreach (var point in network.Points.Values.Where(p => p.IsActive))\n            {\n                if (point.Type == PointType.Receipt)\n                {\n                    var outflow = network.GetOutgoingSegments(point.Id)\n                        .Where(s => result.SegmentFlows.ContainsKey(s.Id))\n                        .Sum(s => result.SegmentFlows[s.Id].Flow);\n                    metrics.TotalSupplyUsed += outflow;\n                }\n                else if (point.Type == PointType.Delivery)\n                {\n                    var inflow = network.GetIncomingSegments(point.Id)\n                        .Where(s => result.SegmentFlows.ContainsKey(s.Id))\n                        .Sum(s => result.SegmentFlows[s.Id].Flow);\n                    metrics.TotalDemandSatisfied += inflow;\n                }\n            }\n\n            // Calculate utilization metrics\n            var utilizationRates = result.SegmentFlows.Values.Select(f => f.UtilizationPercentage).ToList();\n            metrics.AverageCapacityUtilization = utilizationRates.Any() ? utilizationRates.Average() : 0;\n            metrics.PeakCapacityUtilization = utilizationRates.Any() ? utilizationRates.Max() : 0;\n\n            // Count active elements\n            metrics.ActiveSegments = result.SegmentFlows.Values.Count(f => Math.Abs(f.Flow) > 1e-6);\n            metrics.ActiveCompressors = result.PointPressures.Values.Count(p => p.PressureBoost > 1e-6);\n        }\n\n        private void CalculateCosts(OptimizationResult result, PipelineNetwork network, OptimizationSettings settings)\n        {\n            var costs = result.TotalCost;\n            var fuelCost = GetParameterValue(settings, \"FuelCostPerMMscf\", 3.50);\n            var compressorCost = GetParameterValue(settings, \"CompressorOperatingCost\", 0.01);\n\n            // Transportation costs\n            costs.TransportationCost = result.SegmentFlows.Values.Sum(f => f.TransportationCost);\n\n            // Fuel and compressor costs\n            costs.FuelCost = result.PointPressures.Values.Sum(p => p.FuelConsumption * fuelCost);\n            costs.CompressorCost = result.PointPressures.Values.Where(p => p.PressureBoost > 0).Sum(p => p.PressureBoost * compressorCost);\n        }\n    }\n}\n","size_bytes":22817},"Models/OptimizationResult.cs":{"content":"namespace GasPipelineOptimization.Models\n{\n    /// <summary>\n    /// Status of the optimization process\n    /// </summary>\n    public enum OptimizationStatus\n    {\n        NotSolved,\n        Optimal,\n        Feasible,\n        Infeasible,\n        Unbounded,\n        Error\n    }\n\n    /// <summary>\n    /// Result of flow optimization for a specific segment\n    /// </summary>\n    public class SegmentFlowResult\n    {\n        /// <summary>\n        /// Segment identifier\n        /// </summary>\n        public string SegmentId { get; set; } = string.Empty;\n\n        /// <summary>\n        /// Optimized flow through the segment (MMscfd)\n        /// </summary>\n        public double Flow { get; set; }\n\n        /// <summary>\n        /// Utilization percentage of segment capacity\n        /// </summary>\n        public double UtilizationPercentage => Math.Abs(Flow) / Math.Max(1e-6, Capacity) * 100;\n\n        /// <summary>\n        /// Segment capacity\n        /// </summary>\n        public double Capacity { get; set; }\n\n        /// <summary>\n        /// Transportation cost for this flow\n        /// </summary>\n        public double TransportationCost { get; set; }\n    }\n\n    /// <summary>\n    /// Result of pressure optimization for a specific point\n    /// </summary>\n    public class PointPressureResult\n    {\n        /// <summary>\n        /// Point identifier\n        /// </summary>\n        public string PointId { get; set; } = string.Empty;\n\n        /// <summary>\n        /// Optimized pressure at the point (psia)\n        /// </summary>\n        public double Pressure { get; set; }\n\n        /// <summary>\n        /// Pressure squared (used in optimization)\n        /// </summary>\n        public double PressureSquared { get; set; }\n\n        /// <summary>\n        /// Whether pressure constraints are satisfied\n        /// </summary>\n        public bool IsWithinConstraints { get; set; }\n\n        /// <summary>\n        /// For compressor stations: pressure boost applied\n        /// </summary>\n        public double PressureBoost { get; set; }\n\n        /// <summary>\n        /// Fuel consumption at this point (for compressors)\n        /// </summary>\n        public double FuelConsumption { get; set; }\n    }\n\n    /// <summary>\n    /// Comprehensive optimization result\n    /// </summary>\n    public class OptimizationResult\n    {\n        /// <summary>\n        /// Status of the optimization\n        /// </summary>\n        public OptimizationStatus Status { get; set; } = OptimizationStatus.NotSolved;\n\n        /// <summary>\n        /// Objective function value\n        /// </summary>\n        public double ObjectiveValue { get; set; }\n\n        /// <summary>\n        /// Optimization algorithm used\n        /// </summary>\n        public string AlgorithmUsed { get; set; } = string.Empty;\n\n        /// <summary>\n        /// Solver used (GLOP, SCIP, etc.)\n        /// </summary>\n        public string SolverUsed { get; set; } = string.Empty;\n\n        /// <summary>\n        /// Time taken for optimization (milliseconds)\n        /// </summary>\n        public double SolutionTimeMs { get; set; }\n\n        /// <summary>\n        /// Flow results for each segment\n        /// </summary>\n        public Dictionary<string, SegmentFlowResult> SegmentFlows { get; set; } = new();\n\n        /// <summary>\n        /// Pressure results for each point\n        /// </summary>\n        public Dictionary<string, PointPressureResult> PointPressures { get; set; } = new();\n\n        /// <summary>\n        /// Total cost breakdown\n        /// </summary>\n        public CostBreakdown TotalCost { get; set; } = new();\n\n        /// <summary>\n        /// Additional metrics and statistics\n        /// </summary>\n        public OptimizationMetrics Metrics { get; set; } = new();\n\n        /// <summary>\n        /// Any warnings or informational messages\n        /// </summary>\n        public List<string> Messages { get; set; } = new();\n\n        /// <summary>\n        /// Whether all demand requirements were satisfied\n        /// </summary>\n        public bool AllDemandSatisfied => Metrics.TotalDemandSatisfied >= Metrics.TotalDemandRequired - 1e-6;\n\n        /// <summary>\n        /// Whether all capacity constraints were respected\n        /// </summary>\n        public bool AllCapacityConstraintsRespected => SegmentFlows.Values.All(s => Math.Abs(s.Flow) <= s.Capacity + 1e-6);\n\n        /// <summary>\n        /// Adds a segment flow result\n        /// </summary>\n        public void AddSegmentFlow(string segmentId, double flow, double capacity, double cost)\n        {\n            SegmentFlows[segmentId] = new SegmentFlowResult\n            {\n                SegmentId = segmentId,\n                Flow = flow,\n                Capacity = capacity,\n                TransportationCost = cost\n            };\n        }\n\n        /// <summary>\n        /// Adds a point pressure result\n        /// </summary>\n        public void AddPointPressure(string pointId, double pressure, double pressureSquared, \n            bool withinConstraints, double pressureBoost = 0, double fuelConsumption = 0)\n        {\n            PointPressures[pointId] = new PointPressureResult\n            {\n                PointId = pointId,\n                Pressure = pressure,\n                PressureSquared = pressureSquared,\n                IsWithinConstraints = withinConstraints,\n                PressureBoost = pressureBoost,\n                FuelConsumption = fuelConsumption\n            };\n        }\n\n        /// <summary>\n        /// Generates a summary report of the optimization results\n        /// </summary>\n        public string GenerateSummaryReport()\n        {\n            var report = new System.Text.StringBuilder();\n            report.AppendLine(\"=== Gas Pipeline Optimization Results ===\");\n            report.AppendLine($\"Status: {Status}\");\n            report.AppendLine($\"Algorithm: {AlgorithmUsed}\");\n            report.AppendLine($\"Solver: {SolverUsed}\");\n            report.AppendLine($\"Solution Time: {SolutionTimeMs:F2} ms\");\n            report.AppendLine($\"Objective Value: {ObjectiveValue:F2}\");\n            report.AppendLine();\n\n            report.AppendLine(\"=== Cost Breakdown ===\");\n            report.AppendLine($\"Transportation Cost: ${TotalCost.TransportationCost:F2}\");\n            report.AppendLine($\"Fuel Cost: ${TotalCost.FuelCost:F2}\");\n            report.AppendLine($\"Compressor Cost: ${TotalCost.CompressorCost:F2}\");\n            report.AppendLine($\"Total Cost: ${TotalCost.TotalCost:F2}\");\n            report.AppendLine();\n\n            report.AppendLine(\"=== Network Metrics ===\");\n            report.AppendLine($\"Total Supply Used: {Metrics.TotalSupplyUsed:F2} MMscfd\");\n            report.AppendLine($\"Total Demand Satisfied: {Metrics.TotalDemandSatisfied:F2} MMscfd\");\n            report.AppendLine($\"Total Demand Required: {Metrics.TotalDemandRequired:F2} MMscfd\");\n            report.AppendLine($\"Average Capacity Utilization: {Metrics.AverageCapacityUtilization:F1}%\");\n            report.AppendLine($\"Peak Capacity Utilization: {Metrics.PeakCapacityUtilization:F1}%\");\n            report.AppendLine();\n\n            if (SegmentFlows.Any())\n            {\n                report.AppendLine(\"=== Segment Flows ===\");\n                foreach (var flow in SegmentFlows.Values.OrderBy(s => s.SegmentId))\n                {\n                    report.AppendLine($\"{flow.SegmentId}: {flow.Flow:F2} MMscfd ({flow.UtilizationPercentage:F1}% utilization)\");\n                }\n                report.AppendLine();\n            }\n\n            if (PointPressures.Any())\n            {\n                report.AppendLine(\"=== Point Pressures ===\");\n                foreach (var pressure in PointPressures.Values.OrderBy(p => p.PointId))\n                {\n                    var status = pressure.IsWithinConstraints ? \"OK\" : \"VIOLATION\";\n                    report.AppendLine($\"{pressure.PointId}: {pressure.Pressure:F1} psia [{status}]\");\n                    if (pressure.PressureBoost > 0)\n                    {\n                        report.AppendLine($\"  Pressure Boost: {pressure.PressureBoost:F1} psi\");\n                    }\n                    if (pressure.FuelConsumption > 0)\n                    {\n                        report.AppendLine($\"  Fuel Consumption: {pressure.FuelConsumption:F3} MMscf\");\n                    }\n                }\n                report.AppendLine();\n            }\n\n            if (Messages.Any())\n            {\n                report.AppendLine(\"=== Messages ===\");\n                foreach (var message in Messages)\n                {\n                    report.AppendLine($\"- {message}\");\n                }\n            }\n\n            return report.ToString();\n        }\n    }\n\n    /// <summary>\n    /// Cost breakdown for optimization results\n    /// </summary>\n    public class CostBreakdown\n    {\n        /// <summary>\n        /// Total transportation cost through segments\n        /// </summary>\n        public double TransportationCost { get; set; }\n\n        /// <summary>\n        /// Total fuel cost for compressors\n        /// </summary>\n        public double FuelCost { get; set; }\n\n        /// <summary>\n        /// Total compressor operation cost\n        /// </summary>\n        public double CompressorCost { get; set; }\n\n        /// <summary>\n        /// Other miscellaneous costs\n        /// </summary>\n        public double OtherCosts { get; set; }\n\n        /// <summary>\n        /// Total cost of all components\n        /// </summary>\n        public double TotalCost => TransportationCost + FuelCost + CompressorCost + OtherCosts;\n    }\n\n    /// <summary>\n    /// Optimization metrics and statistics\n    /// </summary>\n    public class OptimizationMetrics\n    {\n        /// <summary>\n        /// Total supply capacity used\n        /// </summary>\n        public double TotalSupplyUsed { get; set; }\n\n        /// <summary>\n        /// Total demand actually satisfied\n        /// </summary>\n        public double TotalDemandSatisfied { get; set; }\n\n        /// <summary>\n        /// Total demand required\n        /// </summary>\n        public double TotalDemandRequired { get; set; }\n\n        /// <summary>\n        /// Average capacity utilization across all segments\n        /// </summary>\n        public double AverageCapacityUtilization { get; set; }\n\n        /// <summary>\n        /// Peak capacity utilization (highest among all segments)\n        /// </summary>\n        public double PeakCapacityUtilization { get; set; }\n\n        /// <summary>\n        /// Total throughput in the network\n        /// </summary>\n        public double TotalThroughput { get; set; }\n\n        /// <summary>\n        /// Number of active segments in the solution\n        /// </summary>\n        public int ActiveSegments { get; set; }\n\n        /// <summary>\n        /// Number of compressors operating\n        /// </summary>\n        public int ActiveCompressors { get; set; }\n    }\n}\n","size_bytes":10891},"Models/OptimizationSettings.cs":{"content":"namespace GasPipelineOptimization.Models\n{\n    /// <summary>\n    /// Configuration settings for optimization algorithms\n    /// </summary>\n    public class OptimizationSettings\n    {\n        /// <summary>\n        /// Whether to enable pressure constraints in optimization\n        /// </summary>\n        public bool EnablePressureConstraints { get; set; } = true;\n\n        /// <summary>\n        /// Whether to enable compressor station modeling\n        /// </summary>\n        public bool EnableCompressorStations { get; set; } = true;\n\n        /// <summary>\n        /// Maximum solution time in seconds\n        /// </summary>\n        public double MaxSolutionTimeSeconds { get; set; } = 300;\n\n        /// <summary>\n        /// Tolerance for optimization convergence\n        /// </summary>\n        public double OptimalityTolerance { get; set; } = 1e-6;\n\n        /// <summary>\n        /// Tolerance for constraint feasibility\n        /// </summary>\n        public double FeasibilityTolerance { get; set; } = 1e-6;\n\n        /// <summary>\n        /// Whether to use linear approximation for pressure constraints\n        /// </summary>\n        public bool UseLinearPressureApproximation { get; set; } = true;\n\n        /// <summary>\n        /// Number of segments for piecewise linear approximation\n        /// </summary>\n        public int LinearApproximationSegments { get; set; } = 10;\n\n        /// <summary>\n        /// Preferred solver (GLOP for linear, SCIP for nonlinear)\n        /// </summary>\n        public string PreferredSolver { get; set; } = \"GLOP\";\n\n        /// <summary>\n        /// Objective function weights\n        /// </summary>\n        public ObjectiveWeights Weights { get; set; } = new();\n\n        /// <summary>\n        /// Algorithm-specific parameters\n        /// </summary>\n        public Dictionary<string, object> AlgorithmParameters { get; set; } = new();\n\n        /// <summary>\n        /// Whether to enable detailed logging\n        /// </summary>\n        public bool EnableDetailedLogging { get; set; } = false;\n\n        /// <summary>\n        /// Whether to validate network before optimization\n        /// </summary>\n        public bool ValidateNetworkBeforeOptimization { get; set; } = true;\n\n        /// <summary>\n        /// Minimum flow threshold (flows below this are considered zero)\n        /// </summary>\n        public double MinimumFlowThreshold { get; set; } = 1e-3;\n\n        /// <summary>\n        /// Validates the optimization settings\n        /// </summary>\n        public bool IsValid(out string errorMessage)\n        {\n            errorMessage = string.Empty;\n\n            if (MaxSolutionTimeSeconds <= 0)\n            {\n                errorMessage = \"Maximum solution time must be positive\";\n                return false;\n            }\n\n            if (OptimalityTolerance <= 0 || OptimalityTolerance >= 1)\n            {\n                errorMessage = \"Optimality tolerance must be between 0 and 1\";\n                return false;\n            }\n\n            if (FeasibilityTolerance <= 0 || FeasibilityTolerance >= 1)\n            {\n                errorMessage = \"Feasibility tolerance must be between 0 and 1\";\n                return false;\n            }\n\n            if (LinearApproximationSegments < 1 || LinearApproximationSegments > 100)\n            {\n                errorMessage = \"Linear approximation segments must be between 1 and 100\";\n                return false;\n            }\n\n            if (string.IsNullOrEmpty(PreferredSolver))\n            {\n                errorMessage = \"Preferred solver cannot be empty\";\n                return false;\n            }\n\n            if (MinimumFlowThreshold < 0)\n            {\n                errorMessage = \"Minimum flow threshold cannot be negative\";\n                return false;\n            }\n\n            return true;\n        }\n\n        /// <summary>\n        /// Creates default settings for different optimization scenarios\n        /// </summary>\n        public static OptimizationSettings CreateDefault(string scenario = \"balanced\")\n        {\n            var settings = new OptimizationSettings();\n\n            switch (scenario.ToLower())\n            {\n                case \"throughput\":\n                    settings.Weights.ThroughputWeight = 1.0;\n                    settings.Weights.CostWeight = 0.1;\n                    settings.Weights.BalanceWeight = 0.1;\n                    break;\n\n                case \"cost\":\n                    settings.Weights.ThroughputWeight = 0.1;\n                    settings.Weights.CostWeight = 1.0;\n                    settings.Weights.BalanceWeight = 0.1;\n                    break;\n\n                case \"balance\":\n                    settings.Weights.ThroughputWeight = 0.3;\n                    settings.Weights.CostWeight = 0.3;\n                    settings.Weights.BalanceWeight = 1.0;\n                    break;\n\n                default: // balanced\n                    settings.Weights.ThroughputWeight = 0.5;\n                    settings.Weights.CostWeight = 0.5;\n                    settings.Weights.BalanceWeight = 0.3;\n                    break;\n            }\n\n            return settings;\n        }\n    }\n\n    /// <summary>\n    /// Weights for different objectives in multi-objective optimization\n    /// </summary>\n    public class ObjectiveWeights\n    {\n        /// <summary>\n        /// Weight for maximizing throughput\n        /// </summary>\n        public double ThroughputWeight { get; set; } = 0.5;\n\n        /// <summary>\n        /// Weight for minimizing cost\n        /// </summary>\n        public double CostWeight { get; set; } = 0.5;\n\n        /// <summary>\n        /// Weight for balancing demand across paths\n        /// </summary>\n        public double BalanceWeight { get; set; } = 0.3;\n\n        /// <summary>\n        /// Weight for pressure constraint violations (penalty)\n        /// </summary>\n        public double PressureViolationPenalty { get; set; } = 1000.0;\n\n        /// <summary>\n        /// Weight for capacity constraint violations (penalty)\n        /// </summary>\n        public double CapacityViolationPenalty { get; set; } = 1000.0;\n\n        /// <summary>\n        /// Normalizes weights to sum to 1.0\n        /// </summary>\n        public void Normalize()\n        {\n            var total = ThroughputWeight + CostWeight + BalanceWeight;\n            if (total > 0)\n            {\n                ThroughputWeight /= total;\n                CostWeight /= total;\n                BalanceWeight /= total;\n            }\n        }\n    }\n}\n","size_bytes":6509},"Models/PipelineNetwork.cs":{"content":"using System.Text.Json;\n\nnamespace GasPipelineOptimization.Models\n{\n    /// <summary>\n    /// Represents the complete gas pipeline network\n    /// </summary>\n    public class PipelineNetwork\n    {\n        /// <summary>\n        /// All points in the network\n        /// </summary>\n        public Dictionary<string, Point> Points { get; set; } = new();\n\n        /// <summary>\n        /// All segments in the network\n        /// </summary>\n        public Dictionary<string, Segment> Segments { get; set; } = new();\n\n        /// <summary>\n        /// Network name\n        /// </summary>\n        public string Name { get; set; } = string.Empty;\n\n        /// <summary>\n        /// Network description\n        /// </summary>\n        public string Description { get; set; } = string.Empty;\n\n        /// <summary>\n        /// Adds a point to the network\n        /// </summary>\n        public void AddPoint(Point point)\n        {\n            if (point.IsValid(out string errorMessage))\n            {\n                Points[point.Id] = point;\n            }\n            else\n            {\n                throw new ArgumentException($\"Invalid point: {errorMessage}\");\n            }\n        }\n\n        /// <summary>\n        /// Adds a segment to the network\n        /// </summary>\n        public void AddSegment(Segment segment)\n        {\n            if (!segment.IsValid(out string errorMessage))\n            {\n                throw new ArgumentException($\"Invalid segment: {errorMessage}\");\n            }\n\n            if (!Points.ContainsKey(segment.FromPointId))\n            {\n                throw new ArgumentException($\"From point {segment.FromPointId} does not exist in the network\");\n            }\n\n            if (!Points.ContainsKey(segment.ToPointId))\n            {\n                throw new ArgumentException($\"To point {segment.ToPointId} does not exist in the network\");\n            }\n\n            Segments[segment.Id] = segment;\n        }\n\n        /// <summary>\n        /// Gets all receipt (supply) points\n        /// </summary>\n        public IEnumerable<Point> GetReceiptPoints()\n        {\n            return Points.Values.Where(p => p.Type == PointType.Receipt && p.IsActive);\n        }\n\n        /// <summary>\n        /// Gets all delivery (demand) points\n        /// </summary>\n        public IEnumerable<Point> GetDeliveryPoints()\n        {\n            return Points.Values.Where(p => p.Type == PointType.Delivery && p.IsActive);\n        }\n\n        /// <summary>\n        /// Gets all compressor stations\n        /// </summary>\n        public IEnumerable<Point> GetCompressorStations()\n        {\n            return Points.Values.Where(p => p.Type == PointType.Compressor && p.IsActive);\n        }\n\n        /// <summary>\n        /// Gets all active segments\n        /// </summary>\n        public IEnumerable<Segment> GetActiveSegments()\n        {\n            return Segments.Values.Where(s => s.IsActive);\n        }\n\n        /// <summary>\n        /// Gets segments connected to a specific point\n        /// </summary>\n        public IEnumerable<Segment> GetConnectedSegments(string pointId)\n        {\n            return GetActiveSegments().Where(s => s.FromPointId == pointId || s.ToPointId == pointId);\n        }\n\n        /// <summary>\n        /// Gets segments originating from a specific point\n        /// </summary>\n        public IEnumerable<Segment> GetOutgoingSegments(string pointId)\n        {\n            return GetActiveSegments().Where(s => s.FromPointId == pointId);\n        }\n\n        /// <summary>\n        /// Gets segments ending at a specific point\n        /// </summary>\n        public IEnumerable<Segment> GetIncomingSegments(string pointId)\n        {\n            return GetActiveSegments().Where(s => s.ToPointId == pointId);\n        }\n\n        /// <summary>\n        /// Calculates total supply capacity in the network\n        /// </summary>\n        public double GetTotalSupplyCapacity()\n        {\n            return GetReceiptPoints().Sum(p => p.SupplyCapacity);\n        }\n\n        /// <summary>\n        /// Calculates total demand requirement in the network\n        /// </summary>\n        public double GetTotalDemandRequirement()\n        {\n            return GetDeliveryPoints().Sum(p => p.DemandRequirement);\n        }\n\n        /// <summary>\n        /// Validates the network configuration\n        /// </summary>\n        public bool IsValid(out List<string> errorMessages)\n        {\n            errorMessages = new List<string>();\n\n            // Validate points\n            foreach (var point in Points.Values)\n            {\n                if (!point.IsValid(out string pointError))\n                {\n                    errorMessages.Add($\"Point {point.Id}: {pointError}\");\n                }\n            }\n\n            // Validate segments\n            foreach (var segment in Segments.Values)\n            {\n                if (!segment.IsValid(out string segmentError))\n                {\n                    errorMessages.Add($\"Segment {segment.Id}: {segmentError}\");\n                }\n            }\n\n            // Check network connectivity\n            var receiptPoints = GetReceiptPoints().ToList();\n            var deliveryPoints = GetDeliveryPoints().ToList();\n\n            if (!receiptPoints.Any())\n            {\n                errorMessages.Add(\"Network must have at least one receipt point\");\n            }\n\n            if (!deliveryPoints.Any())\n            {\n                errorMessages.Add(\"Network must have at least one delivery point\");\n            }\n\n            // Check if total supply can meet total demand\n            var totalSupply = GetTotalSupplyCapacity();\n            var totalDemand = GetTotalDemandRequirement();\n\n            if (totalSupply < totalDemand)\n            {\n                errorMessages.Add($\"Total supply ({totalSupply:F2}) is less than total demand ({totalDemand:F2})\");\n            }\n\n            return !errorMessages.Any();\n        }\n\n        /// <summary>\n        /// Loads network from JSON configuration\n        /// </summary>\n        public static PipelineNetwork LoadFromJson(string jsonPath)\n        {\n            try\n            {\n                var jsonString = File.ReadAllText(jsonPath);\n                var network = JsonSerializer.Deserialize<PipelineNetwork>(jsonString, new JsonSerializerOptions\n                {\n                    PropertyNameCaseInsensitive = true\n                });\n\n                if (network == null)\n                {\n                    throw new InvalidOperationException(\"Failed to deserialize network from JSON\");\n                }\n\n                // Calculate pressure drop constants for segments\n                foreach (var segment in network.Segments.Values)\n                {\n                    segment.CalculatePressureDropConstant();\n                }\n\n                return network;\n            }\n            catch (Exception ex)\n            {\n                throw new InvalidOperationException($\"Error loading network from JSON: {ex.Message}\", ex);\n            }\n        }\n\n        /// <summary>\n        /// Saves network to JSON configuration\n        /// </summary>\n        public void SaveToJson(string jsonPath)\n        {\n            try\n            {\n                var jsonString = JsonSerializer.Serialize(this, new JsonSerializerOptions\n                {\n                    WriteIndented = true,\n                    PropertyNamingPolicy = JsonNamingPolicy.CamelCase\n                });\n\n                File.WriteAllText(jsonPath, jsonString);\n            }\n            catch (Exception ex)\n            {\n                throw new InvalidOperationException($\"Error saving network to JSON: {ex.Message}\", ex);\n            }\n        }\n\n        public override string ToString()\n        {\n            return $\"Pipeline Network '{Name}' - Points: {Points.Count}, Segments: {Segments.Count}\";\n        }\n    }\n}\n","size_bytes":7857},"Models/Point.cs":{"content":"using System.ComponentModel.DataAnnotations;\nusing System.Text.Json.Serialization;\n\nnamespace GasPipelineOptimization.Models\n{\n    /// <summary>\n    /// Represents different types of points in the gas pipeline network\n    /// </summary>\n    [JsonConverter(typeof(JsonStringEnumConverter))]\n    public enum PointType\n    {\n        Receipt,    // Supply point\n        Delivery,   // Demand point\n        Compressor  // Compressor station\n    }\n\n    /// <summary>\n    /// Represents a point in the gas pipeline network\n    /// </summary>\n    public class Point\n    {\n        /// <summary>\n        /// Unique identifier for the point\n        /// </summary>\n        public string Id { get; set; } = string.Empty;\n\n        /// <summary>\n        /// Display name for the point\n        /// </summary>\n        public string Name { get; set; } = string.Empty;\n\n        /// <summary>\n        /// Type of the point (Receipt, Delivery, or Compressor)\n        /// </summary>\n        public PointType Type { get; set; }\n\n        /// <summary>\n        /// Supply capacity for Receipt points (MMscfd)\n        /// </summary>\n        public double SupplyCapacity { get; set; }\n\n        /// <summary>\n        /// Demand requirement for Delivery points (MMscfd)\n        /// </summary>\n        public double DemandRequirement { get; set; }\n\n        /// <summary>\n        /// Minimum pressure at this point (psia)\n        /// </summary>\n        public double MinPressure { get; set; }\n\n        /// <summary>\n        /// Maximum pressure at this point (psia)\n        /// </summary>\n        public double MaxPressure { get; set; }\n\n        /// <summary>\n        /// Current pressure at this point (psia)\n        /// </summary>\n        public double CurrentPressure { get; set; }\n\n        /// <summary>\n        /// For compressor stations: maximum pressure boost capability (psi)\n        /// </summary>\n        public double MaxPressureBoost { get; set; }\n\n        /// <summary>\n        /// For compressor stations: fuel consumption rate (MMscf per MMscfd throughput)\n        /// </summary>\n        public double FuelConsumptionRate { get; set; }\n\n        /// <summary>\n        /// Cost per unit of gas at this point ($/MMscf)\n        /// </summary>\n        public double UnitCost { get; set; }\n\n        /// <summary>\n        /// X coordinate for visualization\n        /// </summary>\n        public double X { get; set; }\n\n        /// <summary>\n        /// Y coordinate for visualization\n        /// </summary>\n        public double Y { get; set; }\n\n        /// <summary>\n        /// Whether this point is active in the current optimization\n        /// </summary>\n        public bool IsActive { get; set; } = true;\n\n        public Point()\n        {\n        }\n\n        public Point(string id, string name, PointType type)\n        {\n            Id = id;\n            Name = name;\n            Type = type;\n        }\n\n        /// <summary>\n        /// Validates the point configuration\n        /// </summary>\n        public bool IsValid(out string errorMessage)\n        {\n            errorMessage = string.Empty;\n\n            if (string.IsNullOrEmpty(Id))\n            {\n                errorMessage = \"Point ID cannot be empty\";\n                return false;\n            }\n\n            if (string.IsNullOrEmpty(Name))\n            {\n                errorMessage = \"Point name cannot be empty\";\n                return false;\n            }\n\n            if (MinPressure < 0)\n            {\n                errorMessage = \"Minimum pressure cannot be negative\";\n                return false;\n            }\n\n            if (MaxPressure <= MinPressure)\n            {\n                errorMessage = \"Maximum pressure must be greater than minimum pressure\";\n                return false;\n            }\n\n            if (Type == PointType.Receipt && SupplyCapacity <= 0)\n            {\n                errorMessage = \"Receipt points must have positive supply capacity\";\n                return false;\n            }\n\n            if (Type == PointType.Delivery && DemandRequirement <= 0)\n            {\n                errorMessage = \"Delivery points must have positive demand requirement\";\n                return false;\n            }\n\n            if (Type == PointType.Compressor && MaxPressureBoost <= 0)\n            {\n                errorMessage = \"Compressor stations must have positive pressure boost capability\";\n                return false;\n            }\n\n            return true;\n        }\n\n        public override string ToString()\n        {\n            return $\"{Name} ({Type}) - ID: {Id}\";\n        }\n    }\n}\n","size_bytes":4572},"Models/Segment.cs":{"content":"namespace GasPipelineOptimization.Models\n{\n    /// <summary>\n    /// Represents a pipeline segment connecting two points\n    /// </summary>\n    public class Segment\n    {\n        /// <summary>\n        /// Unique identifier for the segment\n        /// </summary>\n        public string Id { get; set; } = string.Empty;\n\n        /// <summary>\n        /// Display name for the segment\n        /// </summary>\n        public string Name { get; set; } = string.Empty;\n\n        /// <summary>\n        /// Starting point ID\n        /// </summary>\n        public string FromPointId { get; set; } = string.Empty;\n\n        /// <summary>\n        /// Ending point ID\n        /// </summary>\n        public string ToPointId { get; set; } = string.Empty;\n\n        /// <summary>\n        /// Maximum flow capacity through this segment (MMscfd)\n        /// </summary>\n        public double Capacity { get; set; }\n\n        /// <summary>\n        /// Length of the segment (miles)\n        /// </summary>\n        public double Length { get; set; }\n\n        /// <summary>\n        /// Diameter of the pipeline (inches)\n        /// </summary>\n        public double Diameter { get; set; }\n\n        /// <summary>\n        /// Friction factor for pressure drop calculations\n        /// </summary>\n        public double FrictionFactor { get; set; }\n\n        /// <summary>\n        /// Constant k for pressure drop approximation: square(Pfrom) - square(Pto) >= k * square(q)\n        /// </summary>\n        public double PressureDropConstant { get; set; }\n\n        /// <summary>\n        /// Cost per unit flow through this segment ($/MMscf)\n        /// </summary>\n        public double TransportationCost { get; set; }\n\n        /// <summary>\n        /// Current flow through this segment (MMscfd)\n        /// </summary>\n        public double CurrentFlow { get; set; }\n\n        /// <summary>\n        /// Whether this segment is active (available for flow)\n        /// </summary>\n        public bool IsActive { get; set; } = true;\n\n        /// <summary>\n        /// Whether this segment is bidirectional\n        /// </summary>\n        public bool IsBidirectional { get; set; } = false;\n\n        /// <summary>\n        /// Minimum flow through this segment (MMscfd) - can be negative for bidirectional\n        /// </summary>\n        public double MinFlow { get; set; } = 0;\n\n        public Segment()\n        {\n        }\n\n        public Segment(string id, string name, string fromPointId, string toPointId, double capacity)\n        {\n            Id = id;\n            Name = name;\n            FromPointId = fromPointId;\n            ToPointId = toPointId;\n            Capacity = capacity;\n        }\n\n        /// <summary>\n        /// Calculates the pressure drop constant based on physical properties\n        /// </summary>\n        public void CalculatePressureDropConstant()\n        {\n            if (Length > 0 && Diameter > 0 && FrictionFactor > 0)\n            {\n                // Simplified pressure drop calculation\n                // In practice, this would use more complex gas flow equations\n                PressureDropConstant = (FrictionFactor * Length) / (Math.Pow(Diameter, 5) * 1000);\n            }\n        }\n\n        /// <summary>\n        /// Validates the segment configuration\n        /// </summary>\n        public bool IsValid(out string errorMessage)\n        {\n            errorMessage = string.Empty;\n\n            if (string.IsNullOrEmpty(Id))\n            {\n                errorMessage = \"Segment ID cannot be empty\";\n                return false;\n            }\n\n            if (string.IsNullOrEmpty(Name))\n            {\n                errorMessage = \"Segment name cannot be empty\";\n                return false;\n            }\n\n            if (string.IsNullOrEmpty(FromPointId))\n            {\n                errorMessage = \"From point ID cannot be empty\";\n                return false;\n            }\n\n            if (string.IsNullOrEmpty(ToPointId))\n            {\n                errorMessage = \"To point ID cannot be empty\";\n                return false;\n            }\n\n            if (FromPointId == ToPointId)\n            {\n                errorMessage = \"From and To points cannot be the same\";\n                return false;\n            }\n\n            if (Capacity <= 0)\n            {\n                errorMessage = \"Segment capacity must be positive\";\n                return false;\n            }\n\n            if (Length <= 0)\n            {\n                errorMessage = \"Segment length must be positive\";\n                return false;\n            }\n\n            if (Diameter <= 0)\n            {\n                errorMessage = \"Segment diameter must be positive\";\n                return false;\n            }\n\n            return true;\n        }\n\n        /// <summary>\n        /// Gets the effective capacity considering bidirectional flow\n        /// </summary>\n        public double GetEffectiveCapacity()\n        {\n            return IsBidirectional ? Capacity : Math.Max(0, Capacity);\n        }\n\n        /// <summary>\n        /// Gets the effective minimum flow considering bidirectional capability\n        /// </summary>\n        public double GetEffectiveMinFlow()\n        {\n            return IsBidirectional ? -Capacity : Math.Max(0, MinFlow);\n        }\n\n        public override string ToString()\n        {\n            return $\"{Name} ({FromPointId} -> {ToPointId}) - Capacity: {Capacity:F2} MMscfd\";\n        }\n    }\n}\n","size_bytes":5410},"Services/CompressorService.cs":{"content":"using Google.OrTools.LinearSolver;\nusing GasPipelineOptimization.Models;\nusing GasPipelineOptimization.Utilities;\n\nnamespace GasPipelineOptimization.Services\n{\n    /// <summary>\n    /// Service for handling compressor station constraints and operations\n    /// </summary>\n    public class CompressorService\n    {\n        /// <summary>\n        /// Adds compressor constraints to the optimization model\n        /// </summary>\n        public void AddCompressorConstraints(Solver solver, PipelineNetwork network,\n            Dictionary<string, Variable> flowVars, Dictionary<string, Variable> pressureVars,\n            Dictionary<string, Variable> compressorVars, OptimizationSettings settings)\n        {\n            if (!settings.EnableCompressorStations)\n                return;\n\n            foreach (var compressor in network.GetCompressorStations())\n            {\n                AddCompressorOperationConstraints(solver, compressor, flowVars, pressureVars, compressorVars, settings);\n                AddFuelConsumptionConstraints(solver, compressor, flowVars, compressorVars, settings);\n                AddPressureBoostConstraints(solver, compressor, pressureVars, compressorVars, settings);\n            }\n        }\n\n        /// <summary>\n        /// Adds constraints for compressor operation (on/off, capacity limits)\n        /// </summary>\n        private void AddCompressorOperationConstraints(Solver solver, Point compressor,\n            Dictionary<string, Variable> flowVars, Dictionary<string, Variable> pressureVars,\n            Dictionary<string, Variable> compressorVars, OptimizationSettings settings)\n        {\n            if (!compressorVars.TryGetValue($\"{compressor.Id}_active\", out var activeVar))\n                return;\n\n            // Compressor can only boost pressure when active\n            if (compressorVars.TryGetValue($\"{compressor.Id}_boost\", out var boostVar))\n            {\n                // boost <= max_boost * active\n                var maxBoostConstraint = solver.MakeConstraint(0, 0, $\"max_boost_{compressor.Id}\");\n                maxBoostConstraint.SetCoefficient(boostVar, 1.0);\n                maxBoostConstraint.SetCoefficient(activeVar, -compressor.MaxPressureBoost);\n            }\n\n            // Minimum operating flow when compressor is active\n            var incomingSegments = GetIncomingSegments(solver, compressor.Id, flowVars);\n            var totalInflowVar = CreateTotalInflowVariable(solver, compressor.Id, incomingSegments);\n\n            if (totalInflowVar != null)\n            {\n                // Minimum flow constraint: total_inflow >= min_flow * active\n                var minFlow = 10.0; // Minimum operating flow (MMscfd)\n                var minFlowConstraint = solver.MakeConstraint(0, double.PositiveInfinity, $\"min_flow_{compressor.Id}\");\n                minFlowConstraint.SetCoefficient(totalInflowVar, 1.0);\n                minFlowConstraint.SetCoefficient(activeVar, -minFlow);\n            }\n        }\n\n        /// <summary>\n        /// Adds fuel consumption constraints for compressor operation\n        /// </summary>\n        private void AddFuelConsumptionConstraints(Solver solver, Point compressor,\n            Dictionary<string, Variable> flowVars, Dictionary<string, Variable> compressorVars,\n            OptimizationSettings settings)\n        {\n            if (!compressorVars.TryGetValue($\"{compressor.Id}_fuel\", out var fuelVar) ||\n                !compressorVars.TryGetValue($\"{compressor.Id}_active\", out var activeVar))\n                return;\n\n            // Calculate total throughput for fuel consumption\n            var incomingSegments = GetIncomingSegments(solver, compressor.Id, flowVars);\n            var totalInflowVar = CreateTotalInflowVariable(solver, compressor.Id, incomingSegments);\n\n            if (totalInflowVar != null)\n            {\n                // Base fuel consumption: fuel = base_rate * active + flow_rate * throughput\n                var baseFuelRate = 1.0; // Base fuel consumption when running (MMscf/day)\n                var flowFuelRate = compressor.FuelConsumptionRate; // Additional fuel per unit flow\n\n                // fuel >= base_rate * active + flow_rate * throughput\n                var fuelConstraint = solver.MakeConstraint(0, double.PositiveInfinity, $\"fuel_consumption_{compressor.Id}\");\n                fuelConstraint.SetCoefficient(fuelVar, 1.0);\n                fuelConstraint.SetCoefficient(activeVar, -baseFuelRate);\n                fuelConstraint.SetCoefficient(totalInflowVar, -flowFuelRate);\n            }\n\n            // Additional fuel consumption based on pressure boost\n            if (compressorVars.TryGetValue($\"{compressor.Id}_boost\", out var boostVar))\n            {\n                var boostFuelRate = 0.001; // Additional fuel per psi of boost (MMscf/psi/day)\n                \n                var boostFuelConstraint = solver.MakeConstraint(0, double.PositiveInfinity, $\"boost_fuel_{compressor.Id}\");\n                boostFuelConstraint.SetCoefficient(fuelVar, 1.0);\n                boostFuelConstraint.SetCoefficient(boostVar, -boostFuelRate);\n            }\n        }\n\n        /// <summary>\n        /// Adds pressure boost constraints linking inlet and outlet pressures\n        /// </summary>\n        private void AddPressureBoostConstraints(Solver solver, Point compressor,\n            Dictionary<string, Variable> pressureVars, Dictionary<string, Variable> compressorVars,\n            OptimizationSettings settings)\n        {\n            if (!pressureVars.TryGetValue(compressor.Id, out var compressorPressureVar) ||\n                !compressorVars.TryGetValue($\"{compressor.Id}_boost\", out var boostVar))\n                return;\n\n            // For simplification, we assume the compressor pressure variable represents outlet pressure\n            // In a more detailed model, we would have separate inlet and outlet pressure variables\n\n            // The pressure boost constraint would be: P_outlet^2 = P_inlet^2 + boost_factor * boost\n            // This is simplified here - in practice, compressor performance curves would be used\n\n            // Ensure compressor operates within pressure limits\n            var minOutletPressure = compressor.MinPressure * compressor.MinPressure;\n            var maxOutletPressure = compressor.MaxPressure * compressor.MaxPressure;\n\n            solver.MakeConstraint(minOutletPressure, maxOutletPressure, $\"compressor_pressure_limits_{compressor.Id}\")\n                .SetCoefficient(compressorPressureVar, 1.0);\n        }\n\n        /// <summary>\n        /// Gets incoming segments for a compressor station\n        /// </summary>\n        private List<Variable> GetIncomingSegments(Solver solver, string compressorId, \n            Dictionary<string, Variable> flowVars)\n        {\n            var incomingVars = new List<Variable>();\n            \n            foreach (var flowVar in flowVars)\n            {\n                // This is a simplified approach - in practice, we would use the network topology\n                // to determine which segments are actually incoming to the compressor\n                if (flowVar.Key.Contains(compressorId) || flowVar.Key.EndsWith($\"_{compressorId}\"))\n                {\n                    incomingVars.Add(flowVar.Value);\n                }\n            }\n            \n            return incomingVars;\n        }\n\n        /// <summary>\n        /// Creates a variable representing total inflow to a compressor\n        /// </summary>\n        private Variable? CreateTotalInflowVariable(Solver solver, string compressorId, \n            List<Variable> incomingSegments)\n        {\n            if (!incomingSegments.Any())\n                return null;\n\n            var totalInflowVar = solver.MakeNumVar(0, double.PositiveInfinity, $\"total_inflow_{compressorId}\");\n            \n            // total_inflow = sum of incoming flows\n            var inflowConstraint = solver.MakeConstraint(0, 0, $\"inflow_sum_{compressorId}\");\n            inflowConstraint.SetCoefficient(totalInflowVar, 1.0);\n            \n            foreach (var incomingVar in incomingSegments)\n            {\n                inflowConstraint.SetCoefficient(incomingVar, -1.0);\n            }\n            \n            return totalInflowVar;\n        }\n\n        /// <summary>\n        /// Calculates compressor efficiency based on operating conditions\n        /// </summary>\n        public double CalculateCompressorEfficiency(double throughput, double pressureRatio, \n            double designThroughput, double designPressureRatio)\n        {\n            // Simplified efficiency calculation\n            // In practice, this would use detailed compressor performance curves\n            \n            var throughputRatio = throughput / Math.Max(designThroughput, 1e-6);\n            var pressureRatioNormalized = pressureRatio / Math.Max(designPressureRatio, 1.1);\n            \n            // Peak efficiency around design point\n            var throughputFactor = 1.0 - Math.Pow(throughputRatio - 1.0, 2) * 0.1;\n            var pressureFactor = 1.0 - Math.Pow(pressureRatioNormalized - 1.0, 2) * 0.05;\n            \n            var baseEfficiency = 0.85; // Base mechanical efficiency\n            \n            return Math.Max(0.5, Math.Min(0.95, baseEfficiency * throughputFactor * pressureFactor));\n        }\n\n        /// <summary>\n        /// Estimates compressor power requirements\n        /// </summary>\n        public double EstimateCompressorPower(double throughput, double inletPressure, \n            double outletPressure, double gasTemperature = 60.0)\n        {\n            // Simplified power calculation for gas compression\n            // Power = (k/(k-1)) * (inlet_pressure * flow) * ((outlet/inlet)^((k-1)/k) - 1) / efficiency\n            \n            var k = 1.3; // Heat capacity ratio for natural gas\n            var efficiency = 0.85; // Assumed compressor efficiency\n            var gasConstant = 53.35; // ft·lbf/(lbm·°R) for natural gas\n            var temperature = gasTemperature + 459.67; // Convert to Rankine\n            \n            if (inletPressure <= 0 || outletPressure <= inletPressure)\n                return 0;\n            \n            var pressureRatio = outletPressure / inletPressure;\n            var compressionRatio = Math.Pow(pressureRatio, (k - 1) / k);\n            \n            // Convert throughput to mass flow (simplified)\n            var massFlow = throughput * 0.0416667; // MMscfd to lbm/s (approximate)\n            \n            var power = (k / (k - 1)) * gasConstant * temperature * massFlow * (compressionRatio - 1) / efficiency;\n            \n            // Convert to horsepower\n            return power / 550.0;\n        }\n\n        /// <summary>\n        /// Validates compressor constraints in the optimization result\n        /// </summary>\n        public bool ValidateCompressorConstraints(PipelineNetwork network, OptimizationResult result,\n            OptimizationSettings settings, out List<string> violations)\n        {\n            violations = new List<string>();\n\n            if (!settings.EnableCompressorStations)\n                return true;\n\n            foreach (var compressor in network.GetCompressorStations())\n            {\n                if (result.PointPressures.TryGetValue(compressor.Id, out var pressureResult))\n                {\n                    // Check pressure boost limits\n                    if (pressureResult.PressureBoost > compressor.MaxPressureBoost + settings.FeasibilityTolerance)\n                    {\n                        violations.Add($\"Compressor {compressor.Id}: Pressure boost {pressureResult.PressureBoost:F1} \" +\n                            $\"exceeds maximum {compressor.MaxPressureBoost:F1}\");\n                    }\n\n                    // Check fuel consumption reasonableness\n                    var maxReasonableFuel = CalculateMaxReasonableFuel(compressor, result);\n                    if (pressureResult.FuelConsumption > maxReasonableFuel)\n                    {\n                        violations.Add($\"Compressor {compressor.Id}: Fuel consumption {pressureResult.FuelConsumption:F3} \" +\n                            $\"exceeds reasonable maximum {maxReasonableFuel:F3}\");\n                    }\n\n                    // Check pressure limits\n                    if (pressureResult.Pressure > compressor.MaxPressure + settings.FeasibilityTolerance)\n                    {\n                        violations.Add($\"Compressor {compressor.Id}: Outlet pressure {pressureResult.Pressure:F1} \" +\n                            $\"exceeds maximum {compressor.MaxPressure:F1}\");\n                    }\n                }\n            }\n\n            return !violations.Any();\n        }\n\n        /// <summary>\n        /// Calculates maximum reasonable fuel consumption for a compressor\n        /// </summary>\n        private double CalculateMaxReasonableFuel(Point compressor, OptimizationResult result)\n        {\n            // Estimate maximum fuel based on maximum throughput and pressure boost\n            var maxThroughput = 1000.0; // Assume maximum throughput (MMscfd)\n            var maxFuelRate = compressor.FuelConsumptionRate * maxThroughput;\n            var boostFuelRate = compressor.MaxPressureBoost * 0.001; // Additional fuel per psi\n            \n            return maxFuelRate + boostFuelRate + 2.0; // Base consumption + margin\n        }\n\n        /// <summary>\n        /// Optimizes compressor staging for multi-stage compression\n        /// </summary>\n        public List<CompressorStage> OptimizeCompressorStaging(double totalPressureRatio, \n            double maxStageRatio = 3.0)\n        {\n            var stages = new List<CompressorStage>();\n            \n            if (totalPressureRatio <= 1.0)\n                return stages;\n\n            // Calculate optimal number of stages\n            var idealStages = Math.Log(totalPressureRatio) / Math.Log(maxStageRatio);\n            var numStages = Math.Max(1, (int)Math.Ceiling(idealStages));\n            \n            // Calculate pressure ratio per stage\n            var stageRatio = Math.Pow(totalPressureRatio, 1.0 / numStages);\n            \n            for (int i = 0; i < numStages; i++)\n            {\n                stages.Add(new CompressorStage\n                {\n                    StageNumber = i + 1,\n                    PressureRatio = stageRatio,\n                    IsIntercooled = i < numStages - 1 // Intercooling between stages\n                });\n            }\n            \n            return stages;\n        }\n    }\n\n    /// <summary>\n    /// Represents a single stage in a multi-stage compressor\n    /// </summary>\n    public class CompressorStage\n    {\n        public int StageNumber { get; set; }\n        public double PressureRatio { get; set; }\n        public bool IsIntercooled { get; set; }\n        public double Efficiency { get; set; } = 0.85;\n        public double PowerRequirement { get; set; }\n    }\n}\n","size_bytes":14863},"Services/OptimizationEngine.cs":{"content":"using GasPipelineOptimization.Algorithms;\nusing GasPipelineOptimization.Models;\n\nnamespace GasPipelineOptimization.Services\n{\n    /// <summary>\n    /// Main optimization engine that coordinates different algorithms and manages optimization execution\n    /// </summary>\n    public class OptimizationEngine\n    {\n        private readonly Dictionary<string, IOptimizationAlgorithm> _algorithms;\n\n        public OptimizationEngine()\n        {\n            _algorithms = new Dictionary<string, IOptimizationAlgorithm>\n            {\n                { \"MaximizeThroughput\", new MaximizeThroughputAlgorithm() },\n                { \"MinimizeCost\", new MinimizeCostAlgorithm() },\n                { \"BalanceDemand\", new BalanceDemandAlgorithm() }\n            };\n        }\n\n        /// <summary>\n        /// Gets all available optimization algorithms\n        /// </summary>\n        public IEnumerable<string> GetAvailableAlgorithms()\n        {\n            return _algorithms.Keys;\n        }\n\n        /// <summary>\n        /// Gets information about a specific algorithm\n        /// </summary>\n        public IOptimizationAlgorithm? GetAlgorithm(string algorithmName)\n        {\n            _algorithms.TryGetValue(algorithmName, out var algorithm);\n            return algorithm;\n        }\n\n        /// <summary>\n        /// Runs optimization using the specified algorithm\n        /// </summary>\n        public OptimizationResult RunOptimization(string algorithmName, PipelineNetwork network, OptimizationSettings settings)\n        {\n            try\n            {\n                // Validate inputs\n                if (string.IsNullOrEmpty(algorithmName))\n                {\n                    return CreateErrorResult(\"Algorithm name cannot be empty\");\n                }\n\n                if (network == null)\n                {\n                    return CreateErrorResult(\"Pipeline network cannot be null\");\n                }\n\n                if (settings == null)\n                {\n                    return CreateErrorResult(\"Optimization settings cannot be null\");\n                }\n\n                // Validate settings\n                if (!settings.IsValid(out string settingsError))\n                {\n                    return CreateErrorResult($\"Invalid optimization settings: {settingsError}\");\n                }\n\n                // Validate network if requested\n                if (settings.ValidateNetworkBeforeOptimization)\n                {\n                    if (!network.IsValid(out List<string> networkErrors))\n                    {\n                        return CreateErrorResult($\"Invalid network configuration: {string.Join(\", \", networkErrors)}\");\n                    }\n                }\n\n                // Get the algorithm\n                if (!_algorithms.TryGetValue(algorithmName, out var algorithm))\n                {\n                    return CreateErrorResult($\"Unknown algorithm: {algorithmName}. Available algorithms: {string.Join(\", \", _algorithms.Keys)}\");\n                }\n\n                // Check if algorithm can handle the network\n                if (!algorithm.CanHandle(network, settings))\n                {\n                    return CreateErrorResult($\"Algorithm '{algorithmName}' cannot handle the current network configuration\");\n                }\n\n                // Log optimization start\n                if (settings.EnableDetailedLogging)\n                {\n                    Console.WriteLine($\"Starting optimization with algorithm: {algorithmName}\");\n                    Console.WriteLine($\"Network: {network.Points.Count} points, {network.Segments.Count} segments\");\n                    Console.WriteLine($\"Settings: Pressure constraints={settings.EnablePressureConstraints}, Compressors={settings.EnableCompressorStations}\");\n                }\n\n                // Run the optimization\n                var result = algorithm.Optimize(network, settings);\n\n                // Log optimization completion\n                if (settings.EnableDetailedLogging)\n                {\n                    Console.WriteLine($\"Optimization completed with status: {result.Status}\");\n                    Console.WriteLine($\"Solution time: {result.SolutionTimeMs:F2} ms\");\n                    if (result.Status == OptimizationStatus.Optimal || result.Status == OptimizationStatus.Feasible)\n                    {\n                        Console.WriteLine($\"Objective value: {result.ObjectiveValue:F2}\");\n                    }\n                }\n\n                return result;\n            }\n            catch (Exception ex)\n            {\n                return CreateErrorResult($\"Optimization engine error: {ex.Message}\");\n            }\n        }\n\n        /// <summary>\n        /// Runs multiple optimization algorithms for comparison\n        /// </summary>\n        public Dictionary<string, OptimizationResult> RunMultipleOptimizations(\n            IEnumerable<string> algorithmNames, PipelineNetwork network, OptimizationSettings settings)\n        {\n            var results = new Dictionary<string, OptimizationResult>();\n\n            foreach (var algorithmName in algorithmNames)\n            {\n                try\n                {\n                    var result = RunOptimization(algorithmName, network, settings);\n                    results[algorithmName] = result;\n                }\n                catch (Exception ex)\n                {\n                    results[algorithmName] = CreateErrorResult($\"Error running {algorithmName}: {ex.Message}\");\n                }\n            }\n\n            return results;\n        }\n\n        /// <summary>\n        /// Runs scenario analysis with different network configurations\n        /// </summary>\n        public Dictionary<string, OptimizationResult> RunScenarioAnalysis(\n            string algorithmName, Dictionary<string, PipelineNetwork> scenarios, OptimizationSettings settings)\n        {\n            var results = new Dictionary<string, OptimizationResult>();\n\n            foreach (var scenario in scenarios)\n            {\n                try\n                {\n                    var result = RunOptimization(algorithmName, scenario.Value, settings);\n                    results[scenario.Key] = result;\n                }\n                catch (Exception ex)\n                {\n                    results[scenario.Key] = CreateErrorResult($\"Error in scenario {scenario.Key}: {ex.Message}\");\n                }\n            }\n\n            return results;\n        }\n\n        /// <summary>\n        /// Generates a comparative report of multiple optimization results\n        /// </summary>\n        public string GenerateComparativeReport(Dictionary<string, OptimizationResult> results)\n        {\n            var report = new System.Text.StringBuilder();\n            report.AppendLine(\"=== Comparative Optimization Report ===\");\n            report.AppendLine($\"Generated: {DateTime.Now:yyyy-MM-dd HH:mm:ss}\");\n            report.AppendLine();\n\n            // Summary table\n            report.AppendLine(\"Algorithm Comparison:\");\n            report.AppendLine(\"Algorithm\".PadRight(20) + \"Status\".PadRight(12) + \"Objective\".PadRight(15) + \"Time(ms)\".PadRight(12) + \"Total Cost\");\n            report.AppendLine(new string('-', 75));\n\n            foreach (var result in results.OrderBy(r => r.Value.ObjectiveValue))\n            {\n                var algorithm = result.Key.PadRight(20);\n                var status = result.Value.Status.ToString().PadRight(12);\n                var objective = result.Value.ObjectiveValue.ToString(\"F2\").PadRight(15);\n                var time = result.Value.SolutionTimeMs.ToString(\"F0\").PadRight(12);\n                var cost = result.Value.TotalCost.TotalCost.ToString(\"F2\");\n\n                report.AppendLine($\"{algorithm}{status}{objective}{time}${cost}\");\n            }\n\n            report.AppendLine();\n\n            // Detailed analysis\n            foreach (var result in results)\n            {\n                report.AppendLine($\"=== {result.Key} Details ===\");\n                if (result.Value.Status == OptimizationStatus.Optimal || result.Value.Status == OptimizationStatus.Feasible)\n                {\n                    report.AppendLine($\"Total Throughput: {result.Value.Metrics.TotalThroughput:F2} MMscfd\");\n                    report.AppendLine($\"Average Utilization: {result.Value.Metrics.AverageCapacityUtilization:F1}%\");\n                    report.AppendLine($\"Peak Utilization: {result.Value.Metrics.PeakCapacityUtilization:F1}%\");\n                    report.AppendLine($\"Transportation Cost: ${result.Value.TotalCost.TransportationCost:F2}\");\n                    report.AppendLine($\"Fuel Cost: ${result.Value.TotalCost.FuelCost:F2}\");\n                    report.AppendLine($\"Compressor Cost: ${result.Value.TotalCost.CompressorCost:F2}\");\n                }\n                else\n                {\n                    report.AppendLine($\"Optimization failed: {result.Value.Status}\");\n                    if (result.Value.Messages.Any())\n                    {\n                        report.AppendLine($\"Messages: {string.Join(\", \", result.Value.Messages)}\");\n                    }\n                }\n                report.AppendLine();\n            }\n\n            return report.ToString();\n        }\n\n        /// <summary>\n        /// Validates that an optimization result is feasible and consistent\n        /// </summary>\n        public bool ValidateOptimizationResult(OptimizationResult result, PipelineNetwork network, \n            out List<string> validationErrors)\n        {\n            validationErrors = new List<string>();\n            \n            if (result == null)\n            {\n                validationErrors.Add(\"Result is null\");\n                return false;\n            }\n\n            if (result.Status != OptimizationStatus.Optimal && result.Status != OptimizationStatus.Feasible)\n            {\n                validationErrors.Add($\"Optimization was not successful: {result.Status}\");\n                return false;\n            }\n\n            // Validate flow balance at each point\n            foreach (var point in network.Points.Values.Where(p => p.IsActive))\n            {\n                var inflow = network.GetIncomingSegments(point.Id)\n                    .Where(s => result.SegmentFlows.ContainsKey(s.Id))\n                    .Sum(s => result.SegmentFlows[s.Id].Flow);\n\n                var outflow = network.GetOutgoingSegments(point.Id)\n                    .Where(s => result.SegmentFlows.ContainsKey(s.Id))\n                    .Sum(s => result.SegmentFlows[s.Id].Flow);\n\n                var balance = inflow - outflow;\n\n                switch (point.Type)\n                {\n                    case PointType.Receipt:\n                        if (balance > 1e-6 || balance < -point.SupplyCapacity - 1e-6)\n                        {\n                            validationErrors.Add($\"Flow balance violation at receipt point {point.Id}: {balance:F3}\");\n                        }\n                        break;\n                    case PointType.Delivery:\n                        if (Math.Abs(balance - point.DemandRequirement) > 1e-6)\n                        {\n                            validationErrors.Add($\"Demand not satisfied at delivery point {point.Id}: expected {point.DemandRequirement:F3}, got {balance:F3}\");\n                        }\n                        break;\n                    case PointType.Compressor:\n                        if (Math.Abs(balance) > 1e-6)\n                        {\n                            validationErrors.Add($\"Flow balance violation at compressor {point.Id}: {balance:F3}\");\n                        }\n                        break;\n                }\n            }\n\n            // Validate capacity constraints\n            foreach (var segment in network.GetActiveSegments())\n            {\n                if (result.SegmentFlows.TryGetValue(segment.Id, out var flowResult))\n                {\n                    if (Math.Abs(flowResult.Flow) > segment.Capacity + 1e-6)\n                    {\n                        validationErrors.Add($\"Capacity violation at segment {segment.Id}: flow {flowResult.Flow:F3} exceeds capacity {segment.Capacity:F3}\");\n                    }\n                }\n            }\n\n            // Validate pressure constraints if enabled\n            foreach (var point in network.Points.Values.Where(p => p.IsActive))\n            {\n                if (result.PointPressures.TryGetValue(point.Id, out var pressureResult))\n                {\n                    if (pressureResult.Pressure < point.MinPressure - 1e-6 || \n                        pressureResult.Pressure > point.MaxPressure + 1e-6)\n                    {\n                        validationErrors.Add($\"Pressure constraint violation at point {point.Id}: {pressureResult.Pressure:F1} psia (limits: {point.MinPressure:F1}-{point.MaxPressure:F1})\");\n                    }\n                }\n            }\n\n            return !validationErrors.Any();\n        }\n\n        private OptimizationResult CreateErrorResult(string errorMessage)\n        {\n            return new OptimizationResult\n            {\n                Status = OptimizationStatus.Error,\n                Messages = new List<string> { errorMessage },\n                SolutionTimeMs = 0\n            };\n        }\n    }\n}\n","size_bytes":13251},"Services/PressureConstraintService.cs":{"content":"using Google.OrTools.LinearSolver;\nusing GasPipelineOptimization.Models;\nusing GasPipelineOptimization.Utilities;\n\nnamespace GasPipelineOptimization.Services\n{\n    /// <summary>\n    /// Service for handling pressure constraints in gas pipeline optimization\n    /// </summary>\n    public class PressureConstraintService\n    {\n        /// <summary>\n        /// Adds pressure constraints to the optimization model\n        /// </summary>\n        public void AddPressureConstraints(Solver solver, PipelineNetwork network, \n            Dictionary<string, Variable> flowVars, Dictionary<string, Variable> pressureVars, \n            OptimizationSettings settings)\n        {\n            if (!settings.EnablePressureConstraints)\n                return;\n\n            // Add pressure bounds for each point\n            AddPressureBounds(solver, network, pressureVars);\n\n            // Add pressure drop constraints for each segment\n            if (settings.UseLinearPressureApproximation)\n            {\n                AddLinearPressureDropConstraints(solver, network, flowVars, pressureVars, settings);\n            }\n            else\n            {\n                AddNonlinearPressureDropConstraints(solver, network, flowVars, pressureVars, settings);\n            }\n        }\n\n        /// <summary>\n        /// Adds pressure bounds constraints for each point\n        /// </summary>\n        private void AddPressureBounds(Solver solver, PipelineNetwork network, \n            Dictionary<string, Variable> pressureVars)\n        {\n            foreach (var point in network.Points.Values.Where(p => p.IsActive))\n            {\n                if (pressureVars.TryGetValue(point.Id, out var pressureVar))\n                {\n                    var minPressureSquared = point.MinPressure * point.MinPressure;\n                    var maxPressureSquared = point.MaxPressure * point.MaxPressure;\n\n                    // Pressure squared bounds\n                    solver.MakeConstraint(minPressureSquared, maxPressureSquared, $\"pressure_bounds_{point.Id}\")\n                        .SetCoefficient(pressureVar, 1.0);\n                }\n            }\n        }\n\n        /// <summary>\n        /// Adds linear approximation of pressure drop constraints\n        /// </summary>\n        private void AddLinearPressureDropConstraints(Solver solver, PipelineNetwork network,\n            Dictionary<string, Variable> flowVars, Dictionary<string, Variable> pressureVars,\n            OptimizationSettings settings)\n        {\n            foreach (var segment in network.GetActiveSegments())\n            {\n                if (!pressureVars.TryGetValue(segment.FromPointId, out var fromPressureVar) ||\n                    !pressureVars.TryGetValue(segment.ToPointId, out var toPressureVar) ||\n                    !flowVars.TryGetValue(segment.Id, out var flowVar))\n                {\n                    continue;\n                }\n\n                // Linear approximation: P_from^2 - P_to^2 >= k * |flow|\n                // Since we can't handle absolute value directly in linear programming,\n                // we'll use a piecewise linear approximation\n\n                var segments = settings.LinearApproximationSegments;\n                var maxFlow = segment.Capacity;\n                var k = segment.PressureDropConstant;\n\n                for (int i = 0; i < segments; i++)\n                {\n                    var flowPoint = (i + 1) * maxFlow / segments;\n                    var pressureDrop = k * flowPoint * flowPoint;\n\n                    // Create constraint: P_from^2 - P_to^2 >= k * flow_point^2 when flow >= flow_point\n                    var constraint = solver.MakeConstraint(-double.PositiveInfinity, pressureDrop, \n                        $\"pressure_drop_{segment.Id}_seg_{i}\");\n                    \n                    constraint.SetCoefficient(fromPressureVar, 1.0);\n                    constraint.SetCoefficient(toPressureVar, -1.0);\n\n                    // Add flow constraint for this segment of the approximation\n                    if (i > 0)\n                    {\n                        var prevFlowPoint = i * maxFlow / segments;\n                        var slope = (pressureDrop - k * prevFlowPoint * prevFlowPoint) / (flowPoint - prevFlowPoint);\n                        constraint.SetCoefficient(flowVar, -slope);\n                    }\n                }\n            }\n        }\n\n        /// <summary>\n        /// Adds nonlinear pressure drop constraints (requires SCIP solver)\n        /// </summary>\n        private void AddNonlinearPressureDropConstraints(Solver solver, PipelineNetwork network,\n            Dictionary<string, Variable> flowVars, Dictionary<string, Variable> pressureVars,\n            OptimizationSettings settings)\n        {\n            // Note: This is a simplified implementation for nonlinear constraints\n            // In practice, this would require more sophisticated constraint handling\n            // or the use of specialized nonlinear optimization solvers\n\n            foreach (var segment in network.GetActiveSegments())\n            {\n                if (!pressureVars.TryGetValue(segment.FromPointId, out var fromPressureVar) ||\n                    !pressureVars.TryGetValue(segment.ToPointId, out var toPressureVar) ||\n                    !flowVars.TryGetValue(segment.Id, out var flowVar))\n                {\n                    continue;\n                }\n\n                // For SCIP solver, we can add quadratic constraints\n                // P_from^2 - P_to^2 >= k * flow^2\n\n                if (solver.SolverVersion().Contains(\"SCIP\"))\n                {\n                    // Create auxiliary variables for flow squared\n                    var flowSquaredVar = solver.MakeNumVar(0, segment.Capacity * segment.Capacity, \n                        $\"flow_squared_{segment.Id}\");\n\n                    // Constraint: flow_squared = flow^2 (approximated by linearization around operating points)\n                    AddQuadraticApproximation(solver, flowVar, flowSquaredVar, segment.Capacity, settings);\n\n                    // Main pressure drop constraint: P_from^2 - P_to^2 >= k * flow^2\n                    var pressureDropConstraint = solver.MakeConstraint(0, double.PositiveInfinity, \n                        $\"pressure_drop_{segment.Id}\");\n                    \n                    pressureDropConstraint.SetCoefficient(fromPressureVar, 1.0);\n                    pressureDropConstraint.SetCoefficient(toPressureVar, -1.0);\n                    pressureDropConstraint.SetCoefficient(flowSquaredVar, -segment.PressureDropConstant);\n                }\n                else\n                {\n                    // Fall back to linear approximation for GLOP solver\n                    AddLinearPressureDropConstraints(solver, network, flowVars, pressureVars, settings);\n                    return;\n                }\n            }\n        }\n\n        /// <summary>\n        /// Adds quadratic approximation constraints for flow squared\n        /// </summary>\n        private void AddQuadraticApproximation(Solver solver, Variable flowVar, Variable flowSquaredVar, \n            double maxFlow, OptimizationSettings settings)\n        {\n            var segments = settings.LinearApproximationSegments;\n            \n            // Piecewise linear approximation of flow^2\n            for (int i = 0; i < segments; i++)\n            {\n                var x1 = i * maxFlow / segments;\n                var x2 = (i + 1) * maxFlow / segments;\n                var y1 = x1 * x1;\n                var y2 = x2 * x2;\n\n                // Linear segment: flow_squared >= slope * flow + intercept\n                var slope = (y2 - y1) / (x2 - x1);\n                var intercept = y1 - slope * x1;\n\n                var constraint = solver.MakeConstraint(intercept, double.PositiveInfinity, \n                    $\"quad_approx_{flowVar.Name()}_seg_{i}\");\n                \n                constraint.SetCoefficient(flowSquaredVar, 1.0);\n                constraint.SetCoefficient(flowVar, -slope);\n            }\n        }\n\n        /// <summary>\n        /// Validates pressure constraint satisfaction in the solution\n        /// </summary>\n        public bool ValidatePressureConstraints(PipelineNetwork network, OptimizationResult result, \n            OptimizationSettings settings, out List<string> violations)\n        {\n            violations = new List<string>();\n\n            if (!settings.EnablePressureConstraints)\n                return true;\n\n            // Check pressure bounds\n            foreach (var point in network.Points.Values.Where(p => p.IsActive))\n            {\n                if (result.PointPressures.TryGetValue(point.Id, out var pressureResult))\n                {\n                    if (pressureResult.Pressure < point.MinPressure - settings.FeasibilityTolerance)\n                    {\n                        violations.Add($\"Point {point.Id}: Pressure {pressureResult.Pressure:F1} below minimum {point.MinPressure:F1}\");\n                    }\n                    \n                    if (pressureResult.Pressure > point.MaxPressure + settings.FeasibilityTolerance)\n                    {\n                        violations.Add($\"Point {point.Id}: Pressure {pressureResult.Pressure:F1} above maximum {point.MaxPressure:F1}\");\n                    }\n                }\n            }\n\n            // Check pressure drop constraints\n            foreach (var segment in network.GetActiveSegments())\n            {\n                if (result.PointPressures.TryGetValue(segment.FromPointId, out var fromPressure) &&\n                    result.PointPressures.TryGetValue(segment.ToPointId, out var toPressure) &&\n                    result.SegmentFlows.TryGetValue(segment.Id, out var flowResult))\n                {\n                    var pressureDropLeft = fromPressure.PressureSquared - toPressure.PressureSquared;\n                    var pressureDropRight = segment.PressureDropConstant * flowResult.Flow * Math.Abs(flowResult.Flow);\n                    \n                    if (pressureDropLeft < pressureDropRight - settings.FeasibilityTolerance)\n                    {\n                        violations.Add($\"Segment {segment.Id}: Pressure drop constraint violated. \" +\n                            $\"Required: {pressureDropRight:F2}, Actual: {pressureDropLeft:F2}\");\n                    }\n                }\n            }\n\n            return !violations.Any();\n        }\n\n        /// <summary>\n        /// Calculates pressure at delivery points based on flow and network topology\n        /// </summary>\n        public Dictionary<string, double> CalculateDeliveryPressures(PipelineNetwork network, \n            Dictionary<string, double> flows, Dictionary<string, double> sourcePressures)\n        {\n            var deliveryPressures = new Dictionary<string, double>();\n\n            foreach (var deliveryPoint in network.GetDeliveryPoints())\n            {\n                var pressure = CalculatePressureAtPoint(network, deliveryPoint.Id, flows, sourcePressures);\n                deliveryPressures[deliveryPoint.Id] = pressure;\n            }\n\n            return deliveryPressures;\n        }\n\n        /// <summary>\n        /// Calculates pressure at a specific point using flow-based pressure drop\n        /// </summary>\n        private double CalculatePressureAtPoint(PipelineNetwork network, string pointId, \n            Dictionary<string, double> flows, Dictionary<string, double> sourcePressures)\n        {\n            // This is a simplified calculation - in practice, this would use\n            // more sophisticated hydraulic calculations\n            \n            var incomingSegments = network.GetIncomingSegments(pointId).ToList();\n            \n            if (!incomingSegments.Any())\n            {\n                // Source point - return source pressure if available\n                return sourcePressures.TryGetValue(pointId, out var sourcePressure) ? sourcePressure : 0;\n            }\n\n            // Calculate weighted average pressure from incoming segments\n            var totalFlow = 0.0;\n            var weightedPressure = 0.0;\n\n            foreach (var segment in incomingSegments)\n            {\n                if (flows.TryGetValue(segment.Id, out var flow) && flow > 0)\n                {\n                    var upstreamPressure = CalculatePressureAtPoint(network, segment.FromPointId, flows, sourcePressures);\n                    var pressureDrop = MathUtils.CalculatePressureDrop(flow, segment.PressureDropConstant);\n                    var downstreamPressure = Math.Sqrt(Math.Max(0, upstreamPressure * upstreamPressure - pressureDrop));\n                    \n                    weightedPressure += downstreamPressure * flow;\n                    totalFlow += flow;\n                }\n            }\n\n            return totalFlow > 0 ? weightedPressure / totalFlow : 0;\n        }\n\n        /// <summary>\n        /// Estimates required compressor boost to meet pressure requirements\n        /// </summary>\n        public Dictionary<string, double> EstimateRequiredCompressorBoost(PipelineNetwork network, \n            Dictionary<string, double> flows, OptimizationSettings settings)\n        {\n            var requiredBoosts = new Dictionary<string, double>();\n\n            foreach (var compressor in network.GetCompressorStations())\n            {\n                var incomingSegments = network.GetIncomingSegments(compressor.Id);\n                var outgoingSegments = network.GetOutgoingSegments(compressor.Id);\n\n                if (incomingSegments.Any() && outgoingSegments.Any())\n                {\n                    // Calculate minimum inlet pressure\n                    var minInletPressure = incomingSegments\n                        .Where(s => flows.ContainsKey(s.Id) && flows[s.Id] > 0)\n                        .Min(s => EstimateSegmentOutletPressure(network, s, flows[s.Id]));\n\n                    // Calculate required outlet pressure\n                    var requiredOutletPressure = outgoingSegments\n                        .Where(s => flows.ContainsKey(s.Id) && flows[s.Id] > 0)\n                        .Max(s => EstimateSegmentInletPressure(network, s, flows[s.Id]));\n\n                    // Required boost\n                    var requiredBoost = Math.Max(0, requiredOutletPressure - minInletPressure);\n                    requiredBoosts[compressor.Id] = Math.Min(requiredBoost, compressor.MaxPressureBoost);\n                }\n            }\n\n            return requiredBoosts;\n        }\n\n        private double EstimateSegmentOutletPressure(PipelineNetwork network, Segment segment, double flow)\n        {\n            if (network.Points.TryGetValue(segment.FromPointId, out var fromPoint))\n            {\n                var inletPressure = fromPoint.CurrentPressure;\n                var pressureDrop = MathUtils.CalculatePressureDrop(flow, segment.PressureDropConstant);\n                return Math.Sqrt(Math.Max(0, inletPressure * inletPressure - pressureDrop));\n            }\n            return 0;\n        }\n\n        private double EstimateSegmentInletPressure(PipelineNetwork network, Segment segment, double flow)\n        {\n            if (network.Points.TryGetValue(segment.ToPointId, out var toPoint))\n            {\n                var outletPressure = toPoint.MinPressure; // Target minimum delivery pressure\n                var pressureDrop = MathUtils.CalculatePressureDrop(flow, segment.PressureDropConstant);\n                return Math.Sqrt(outletPressure * outletPressure + pressureDrop);\n            }\n            return 0;\n        }\n    }\n}\n","size_bytes":15505},"Utilities/MathUtils.cs":{"content":"namespace GasPipelineOptimization.Utilities\n{\n    /// <summary>\n    /// Mathematical utility functions for gas pipeline optimization calculations\n    /// </summary>\n    public static class MathUtils\n    {\n        /// <summary>\n        /// Calculates pressure drop using the simplified gas flow equation\n        /// </summary>\n        /// <param name=\"flow\">Gas flow rate (MMscfd)</param>\n        /// <param name=\"frictionConstant\">Friction constant k</param>\n        /// <returns>Pressure drop (psi²)</returns>\n        public static double CalculatePressureDrop(double flow, double frictionConstant)\n        {\n            return frictionConstant * flow * Math.Abs(flow);\n        }\n\n        /// <summary>\n        /// Calculates pressure drop using Weymouth equation for gas pipelines\n        /// </summary>\n        /// <param name=\"flow\">Gas flow rate (MMscfd)</param>\n        /// <param name=\"diameter\">Pipe diameter (inches)</param>\n        /// <param name=\"length\">Pipe length (miles)</param>\n        /// <param name=\"temperature\">Gas temperature (°F)</param>\n        /// <param name=\"specificGravity\">Specific gravity of gas</param>\n        /// <param name=\"compressibilityFactor\">Gas compressibility factor</param>\n        /// <returns>Pressure drop (psi²)</returns>\n        public static double CalculateWeymouthPressureDrop(double flow, double diameter, double length,\n            double temperature = 60.0, double specificGravity = 0.6, double compressibilityFactor = 0.9)\n        {\n            // Weymouth equation: ΔP² = (433.5 * Q² * L * T * G * Z) / D^5.31\n            var temperatureR = temperature + 459.67; // Convert to Rankine\n            var pressureDropSquared = (433.5 * flow * flow * length * temperatureR * specificGravity * compressibilityFactor) \n                                    / Math.Pow(diameter, 5.31);\n            \n            return Math.Max(0, pressureDropSquared);\n        }\n\n        /// <summary>\n        /// Calculates pressure drop using Panhandle A equation\n        /// </summary>\n        public static double CalculatePanhandleAPressureDrop(double flow, double diameter, double length,\n            double temperature = 60.0, double specificGravity = 0.6, double compressibilityFactor = 0.9,\n            double efficiency = 1.0)\n        {\n            // Panhandle A: Q = 435.87 * E * (P1² - P2²)^0.5394 * D^2.6182 / (G^0.5394 * T^0.5394 * L^0.5394 * Z^0.5394)\n            var temperatureR = temperature + 459.67;\n            var factor = 435.87 * efficiency * Math.Pow(diameter, 2.6182) / \n                        (Math.Pow(specificGravity * temperatureR * length * compressibilityFactor, 0.5394));\n            \n            var pressureDropTerm = Math.Pow(flow / factor, 1.0 / 0.5394);\n            return Math.Max(0, pressureDropTerm);\n        }\n\n        /// <summary>\n        /// Calculates gas compressibility factor using simplified correlation\n        /// </summary>\n        public static double CalculateCompressibilityFactor(double pressure, double temperature,\n            double specificGravity = 0.6)\n        {\n            // Simplified Standing-Katz correlation\n            var temperatureR = temperature + 459.67;\n            var pseudoCriticalPressure = 677 + 15.0 * specificGravity - 37.5 * specificGravity * specificGravity;\n            var pseudoCriticalTemperature = 168 + 325 * specificGravity - 12.5 * specificGravity * specificGravity;\n            \n            var reducedPressure = pressure / pseudoCriticalPressure;\n            var reducedTemperature = temperatureR / pseudoCriticalTemperature;\n            \n            // Simplified Z-factor calculation\n            var z = 1.0 - (0.2 * reducedPressure / reducedTemperature);\n            z += Math.Pow(reducedPressure, 2) * (0.04 - 0.001 * reducedTemperature) / reducedTemperature;\n            \n            return Math.Max(0.5, Math.Min(1.2, z));\n        }\n\n        /// <summary>\n        /// Calculates Reynolds number for gas flow in pipe\n        /// </summary>\n        public static double CalculateReynoldsNumber(double flow, double diameter, double viscosity,\n            double density)\n        {\n            if (diameter <= 0 || viscosity <= 0)\n                return 0;\n            \n            // Convert flow to velocity (simplified)\n            var area = Math.PI * Math.Pow(diameter / 24.0, 2); // Convert diameter to feet and calculate area\n            var velocity = flow / (area * 86400); // ft/s (simplified conversion)\n            \n            return (density * velocity * diameter / 12.0) / viscosity; // Convert diameter to feet\n        }\n\n        /// <summary>\n        /// Calculates Darcy friction factor using Colebrook-White equation\n        /// </summary>\n        public static double CalculateFrictionFactor(double reynoldsNumber, double relativeRoughness)\n        {\n            if (reynoldsNumber <= 0)\n                return 0.02; // Default value\n            \n            if (reynoldsNumber < 2300)\n            {\n                // Laminar flow\n                return 64.0 / reynoldsNumber;\n            }\n            else\n            {\n                // Turbulent flow - simplified Colebrook approximation\n                var term1 = relativeRoughness / 3.7;\n                var term2 = 2.51 / reynoldsNumber;\n                \n                // Iterative solution approximation\n                var f = 0.02; // Initial guess\n                for (int i = 0; i < 5; i++)\n                {\n                    var fNew = Math.Pow(-2.0 * Math.Log10(term1 + term2 / Math.Sqrt(f)), -2);\n                    if (Math.Abs(fNew - f) < 1e-6)\n                        break;\n                    f = fNew;\n                }\n                \n                return Math.Max(0.008, Math.Min(0.1, f));\n            }\n        }\n\n        /// <summary>\n        /// Performs linear interpolation between two points\n        /// </summary>\n        public static double LinearInterpolation(double x, double x1, double y1, double x2, double y2)\n        {\n            if (Math.Abs(x2 - x1) < 1e-10)\n                return y1;\n            \n            return y1 + (y2 - y1) * (x - x1) / (x2 - x1);\n        }\n\n        /// <summary>\n        /// Performs piecewise linear interpolation\n        /// </summary>\n        public static double PiecewiseLinearInterpolation(double x, List<(double X, double Y)> points)\n        {\n            if (!points.Any())\n                return 0;\n            \n            if (points.Count == 1)\n                return points[0].Y;\n            \n            // Sort points by X value\n            var sortedPoints = points.OrderBy(p => p.X).ToList();\n            \n            // Handle extrapolation\n            if (x <= sortedPoints.First().X)\n                return sortedPoints.First().Y;\n            \n            if (x >= sortedPoints.Last().X)\n                return sortedPoints.Last().Y;\n            \n            // Find interpolation interval\n            for (int i = 0; i < sortedPoints.Count - 1; i++)\n            {\n                if (x >= sortedPoints[i].X && x <= sortedPoints[i + 1].X)\n                {\n                    return LinearInterpolation(x, \n                        sortedPoints[i].X, sortedPoints[i].Y,\n                        sortedPoints[i + 1].X, sortedPoints[i + 1].Y);\n                }\n            }\n            \n            return 0;\n        }\n\n        /// <summary>\n        /// Calculates percentage difference between two values\n        /// </summary>\n        public static double PercentageDifference(double value1, double value2)\n        {\n            var average = (Math.Abs(value1) + Math.Abs(value2)) / 2.0;\n            return average > 1e-10 ? Math.Abs(value1 - value2) / average * 100.0 : 0;\n        }\n\n        /// <summary>\n        /// Normalizes a value to a range [0, 1]\n        /// </summary>\n        public static double Normalize(double value, double min, double max)\n        {\n            if (Math.Abs(max - min) < 1e-10)\n                return 0;\n            \n            return Math.Max(0, Math.Min(1, (value - min) / (max - min)));\n        }\n\n        /// <summary>\n        /// Calculates weighted average of values\n        /// </summary>\n        public static double WeightedAverage(IEnumerable<(double Value, double Weight)> data)\n        {\n            var totalWeight = data.Sum(d => d.Weight);\n            if (totalWeight <= 0)\n                return 0;\n            \n            return data.Sum(d => d.Value * d.Weight) / totalWeight;\n        }\n\n        /// <summary>\n        /// Calculates standard deviation of a collection of values\n        /// </summary>\n        public static double StandardDeviation(IEnumerable<double> values)\n        {\n            var valueList = values.ToList();\n            if (!valueList.Any())\n                return 0;\n            \n            var mean = valueList.Average();\n            var squaredDeviations = valueList.Select(v => Math.Pow(v - mean, 2));\n            var variance = squaredDeviations.Average();\n            \n            return Math.Sqrt(variance);\n        }\n\n        /// <summary>\n        /// Solves quadratic equation ax² + bx + c = 0\n        /// </summary>\n        public static (double? Root1, double? Root2) SolveQuadratic(double a, double b, double c)\n        {\n            if (Math.Abs(a) < 1e-10)\n            {\n                // Linear equation: bx + c = 0\n                if (Math.Abs(b) < 1e-10)\n                    return (null, null);\n                \n                var root = -c / b;\n                return (root, null);\n            }\n            \n            var discriminant = b * b - 4 * a * c;\n            \n            if (discriminant < 0)\n                return (null, null); // No real roots\n            \n            if (Math.Abs(discriminant) < 1e-10)\n            {\n                // One root\n                var root = -b / (2 * a);\n                return (root, null);\n            }\n            \n            // Two roots\n            var sqrtDiscriminant = Math.Sqrt(discriminant);\n            var root1 = (-b + sqrtDiscriminant) / (2 * a);\n            var root2 = (-b - sqrtDiscriminant) / (2 * a);\n            \n            return (root1, root2);\n        }\n\n        /// <summary>\n        /// Converts units for gas flow calculations\n        /// </summary>\n        public static class UnitConversions\n        {\n            /// <summary>\n            /// Converts MMscfd to cubic meters per day\n            /// </summary>\n            public static double MMscfdToCubicMetersPerDay(double mmscfd)\n            {\n                return mmscfd * 28316.8; // 1 MMscf = 28,316.8 m³\n            }\n\n            /// <summary>\n            /// Converts psia to bara\n            /// </summary>\n            public static double PsiaToBara(double psia)\n            {\n                return psia * 0.0689476; // 1 psi = 0.0689476 bar\n            }\n\n            /// <summary>\n            /// Converts miles to kilometers\n            /// </summary>\n            public static double MilesToKilometers(double miles)\n            {\n                return miles * 1.60934;\n            }\n\n            /// <summary>\n            /// Converts inches to millimeters\n            /// </summary>\n            public static double InchesToMillimeters(double inches)\n            {\n                return inches * 25.4;\n            }\n\n            /// <summary>\n            /// Converts Fahrenheit to Celsius\n            /// </summary>\n            public static double FahrenheitToCelsius(double fahrenheit)\n            {\n                return (fahrenheit - 32) * 5.0 / 9.0;\n            }\n        }\n    }\n}\n","size_bytes":11551},"Visualization/Services/VisualizationService.cs":{"content":"using System.Diagnostics;\nusing System.Text.Json;\nusing GasPipelineOptimization.Models;\n\nnamespace GasPipelineOptimization.Visualization.Services\n{\n    /// <summary>\n    /// Service for launching and managing the web-based visualization interface\n    /// This service handles the integration between the C# optimization engine and the HTML/JavaScript visualization\n    /// </summary>\n    public class VisualizationService\n    {\n        private readonly string _visualizationPath;\n        private readonly int _defaultPort = 5000;\n\n        /// <summary>\n        /// Initialize the visualization service with the path to the HTML visualization file\n        /// </summary>\n        /// <param name=\"visualizationPath\">Path to the HTML visualization file</param>\n        public VisualizationService(string? visualizationPath = null)\n        {\n            // Default to the embedded visualization file in the project\n            _visualizationPath = visualizationPath ?? Path.Combine(\n                AppDomain.CurrentDomain.BaseDirectory, \n                \"Visualization\", \"Web\", \"PipelineVisualization.html\");\n        }\n\n        /// <summary>\n        /// Launch the web-based visualization with the current network configuration\n        /// This method starts a simple HTTP server to serve the visualization and opens it in the default browser\n        /// </summary>\n        /// <param name=\"network\">Pipeline network to visualize</param>\n        /// <param name=\"optimizationResult\">Optional optimization results to overlay on the visualization</param>\n        /// <returns>True if visualization was launched successfully</returns>\n        public async Task<bool> LaunchVisualizationAsync(PipelineNetwork network, OptimizationResult? optimizationResult = null)\n        {\n            try\n            {\n                // Validate that the visualization file exists\n                if (!File.Exists(_visualizationPath))\n                {\n                    Console.WriteLine($\"Warning: Visualization file not found at {_visualizationPath}\");\n                    Console.WriteLine(\"Creating default visualization from template...\");\n                    await CreateDefaultVisualizationAsync();\n                }\n\n                // Save network and optimization data to temporary files for the web interface to load\n                var tempDir = Path.Combine(Path.GetTempPath(), \"GasPipelineVisualization\");\n                Directory.CreateDirectory(tempDir);\n\n                var networkFile = Path.Combine(tempDir, \"current_network.json\");\n                var resultFile = Path.Combine(tempDir, \"current_results.json\");\n\n                // Serialize network data to JSON for web visualization\n                await SaveNetworkForVisualizationAsync(network, networkFile);\n\n                // Serialize optimization results if available\n                if (optimizationResult != null)\n                {\n                    await SaveResultsForVisualizationAsync(optimizationResult, resultFile);\n                }\n\n                // Start a simple HTTP server to serve the visualization\n                var serverProcess = await StartVisualizationServerAsync();\n\n                if (serverProcess != null)\n                {\n                    Console.WriteLine($\"Visualization server started on http://localhost:{_defaultPort}\");\n                    \n                    // Open the visualization in the default browser\n                    await OpenVisualizationInBrowserAsync();\n                    \n                    Console.WriteLine(\"Press any key to stop the visualization server...\");\n                    Console.ReadKey();\n                    \n                    // Clean up server process\n                    serverProcess.Kill();\n                    serverProcess.Dispose();\n                    \n                    return true;\n                }\n\n                return false;\n            }\n            catch (Exception ex)\n            {\n                Console.WriteLine($\"Failed to launch visualization: {ex.Message}\");\n                return false;\n            }\n        }\n\n        /// <summary>\n        /// Export the current network and optimization results to files that can be loaded by the web visualization\n        /// This allows users to manually open the visualization and load their data\n        /// </summary>\n        /// <param name=\"network\">Pipeline network to export</param>\n        /// <param name=\"optimizationResult\">Optimization results to export</param>\n        /// <param name=\"outputDirectory\">Directory to save the exported files</param>\n        /// <returns>Paths to the exported files</returns>\n        public async Task<(string networkFile, string? resultsFile)> ExportVisualizationDataAsync(\n            PipelineNetwork network, \n            OptimizationResult? optimizationResult = null, \n            string? outputDirectory = null)\n        {\n            outputDirectory ??= Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.Desktop), \"PipelineVisualization\");\n            Directory.CreateDirectory(outputDirectory);\n\n            var networkFile = Path.Combine(outputDirectory, $\"network_{DateTime.Now:yyyyMMdd_HHmmss}.json\");\n            await SaveNetworkForVisualizationAsync(network, networkFile);\n\n            string? resultsFile = null;\n            if (optimizationResult != null)\n            {\n                resultsFile = Path.Combine(outputDirectory, $\"results_{DateTime.Now:yyyyMMdd_HHmmss}.json\");\n                await SaveResultsForVisualizationAsync(optimizationResult, resultsFile);\n            }\n\n            // Copy the visualization HTML file to the output directory for convenience\n            var visualizationCopy = Path.Combine(outputDirectory, \"PipelineVisualization.html\");\n            if (File.Exists(_visualizationPath))\n            {\n                File.Copy(_visualizationPath, visualizationCopy, true);\n            }\n\n            Console.WriteLine($\"Visualization data exported to: {outputDirectory}\");\n            Console.WriteLine($\"Open {visualizationCopy} in a web browser and load the data files.\");\n\n            return (networkFile, resultsFile);\n        }\n\n        /// <summary>\n        /// Save pipeline network data in a format optimized for web visualization\n        /// The JSON format includes all necessary data for rendering the network topology\n        /// </summary>\n        /// <param name=\"network\">Network to save</param>\n        /// <param name=\"filePath\">Output file path</param>\n        private async Task SaveNetworkForVisualizationAsync(PipelineNetwork network, string filePath)\n        {\n            // Create a visualization-optimized representation of the network\n            var visualizationData = new\n            {\n                metadata = new\n                {\n                    name = network.Name ?? \"Pipeline Network\",\n                    description = network.Description ?? \"Gas pipeline network for optimization\",\n                    exportTime = DateTime.UtcNow,\n                    totalPoints = network.Points.Count,\n                    totalSegments = network.Segments.Count\n                },\n                points = network.Points.ToDictionary(kvp => kvp.Key, kvp => new\n                {\n                    id = kvp.Value.Id,\n                    name = kvp.Value.Name,\n                    type = kvp.Value.Type.ToString(),\n                    x = kvp.Value.X,\n                    y = kvp.Value.Y,\n                    isActive = kvp.Value.IsActive,\n                    currentPressure = kvp.Value.CurrentPressure,\n                    minPressure = kvp.Value.MinPressure,\n                    maxPressure = kvp.Value.MaxPressure,\n                    supplyCapacity = kvp.Value.SupplyCapacity,\n                    demandRequirement = kvp.Value.DemandRequirement,\n                    maxPressureBoost = kvp.Value.MaxPressureBoost,\n                    fuelConsumptionRate = kvp.Value.FuelConsumptionRate,\n                    unitCost = kvp.Value.UnitCost\n                }),\n                segments = network.Segments.ToDictionary(kvp => kvp.Key, kvp => new\n                {\n                    id = kvp.Value.Id,\n                    name = kvp.Value.Name,\n                    fromPointId = kvp.Value.FromPointId,\n                    toPointId = kvp.Value.ToPointId,\n                    capacity = kvp.Value.Capacity,\n                    length = kvp.Value.Length,\n                    diameter = kvp.Value.Diameter,\n                    currentFlow = kvp.Value.CurrentFlow,\n                    isActive = kvp.Value.IsActive,\n                    isBidirectional = kvp.Value.IsBidirectional,\n                    minFlow = kvp.Value.MinFlow,\n                    transportationCost = kvp.Value.TransportationCost,\n                    frictionFactor = kvp.Value.FrictionFactor,\n                    pressureDropConstant = kvp.Value.PressureDropConstant\n                })\n            };\n\n            var jsonOptions = new JsonSerializerOptions\n            {\n                WriteIndented = true,\n                PropertyNamingPolicy = JsonNamingPolicy.CamelCase\n            };\n\n            var jsonContent = JsonSerializer.Serialize(visualizationData, jsonOptions);\n            await File.WriteAllTextAsync(filePath, jsonContent);\n        }\n\n        /// <summary>\n        /// Save optimization results in a format suitable for web visualization overlay\n        /// </summary>\n        /// <param name=\"result\">Optimization result to save</param>\n        /// <param name=\"filePath\">Output file path</param>\n        private async Task SaveResultsForVisualizationAsync(OptimizationResult result, string filePath)\n        {\n            var visualizationResults = new\n            {\n                metadata = new\n                {\n                    algorithmUsed = result.AlgorithmUsed,\n                    solverUsed = result.SolverUsed,\n                    status = result.Status.ToString(),\n                    solutionTimeMs = result.SolutionTimeMs,\n                    objectiveValue = result.ObjectiveValue,\n                    exportTime = DateTime.UtcNow\n                },\n                pointPressures = result.PointPressures,\n                segmentFlows = result.SegmentFlows,\n                compressorBoosts = result.PointPressures.ToDictionary(kvp => kvp.Key, kvp => kvp.Value.PressureBoost),\n                statistics = new\n                {\n                    totalThroughput = result.SegmentFlows.Values.Where(f => f.Flow > 0).Sum(f => f.Flow),\n                    maxUtilization = result.SegmentFlows.Any() ? result.SegmentFlows.Values.Max(f => f.Flow) : 0,\n                    avgUtilization = result.SegmentFlows.Any() ? result.SegmentFlows.Values.Average(f => f.Flow) : 0,\n                    activeSegments = result.SegmentFlows.Count(kvp => Math.Abs(kvp.Value.Flow) > 0.1),\n                    activeCompressors = result.PointPressures.Count(kvp => kvp.Value.PressureBoost > 0.1)\n                },\n                messages = result.Messages\n            };\n\n            var jsonOptions = new JsonSerializerOptions\n            {\n                WriteIndented = true,\n                PropertyNamingPolicy = JsonNamingPolicy.CamelCase\n            };\n\n            var jsonContent = JsonSerializer.Serialize(visualizationResults, jsonOptions);\n            await File.WriteAllTextAsync(filePath, jsonContent);\n        }\n\n        /// <summary>\n        /// Start a simple HTTP server to serve the visualization files\n        /// Uses Python's built-in HTTP server for cross-platform compatibility\n        /// </summary>\n        /// <returns>Process handle for the HTTP server, or null if failed to start</returns>\n        private async Task<Process?> StartVisualizationServerAsync()\n        {\n            try\n            {\n                var visualizationDirectory = Path.GetDirectoryName(_visualizationPath);\n                if (string.IsNullOrEmpty(visualizationDirectory))\n                {\n                    return null;\n                }\n\n                // Try to start Python HTTP server (most reliable cross-platform option)\n                var pythonProcess = new Process\n                {\n                    StartInfo = new ProcessStartInfo\n                    {\n                        FileName = \"python3\",\n                        Arguments = $\"-m http.server {_defaultPort}\",\n                        WorkingDirectory = visualizationDirectory,\n                        UseShellExecute = false,\n                        RedirectStandardOutput = true,\n                        RedirectStandardError = true,\n                        CreateNoWindow = true\n                    }\n                };\n\n                pythonProcess.Start();\n\n                // Wait a moment for the server to start\n                await Task.Delay(2000);\n\n                if (!pythonProcess.HasExited)\n                {\n                    return pythonProcess;\n                }\n\n                // If Python3 failed, try python\n                pythonProcess.StartInfo.FileName = \"python\";\n                pythonProcess.Start();\n                await Task.Delay(2000);\n\n                if (!pythonProcess.HasExited)\n                {\n                    return pythonProcess;\n                }\n\n                Console.WriteLine(\"Failed to start Python HTTP server. Please ensure Python is installed.\");\n                return null;\n            }\n            catch (Exception ex)\n            {\n                Console.WriteLine($\"Failed to start visualization server: {ex.Message}\");\n                Console.WriteLine(\"You can manually open the visualization HTML file in a web browser.\");\n                return null;\n            }\n        }\n\n        /// <summary>\n        /// Open the visualization in the default web browser\n        /// Uses platform-specific commands to launch the browser\n        /// </summary>\n        private async Task OpenVisualizationInBrowserAsync()\n        {\n            try\n            {\n                var url = $\"http://localhost:{_defaultPort}/PipelineVisualization.html\";\n                \n                // Platform-specific browser launching\n                if (OperatingSystem.IsWindows())\n                {\n                    Process.Start(new ProcessStartInfo(url) { UseShellExecute = true });\n                }\n                else if (OperatingSystem.IsMacOS())\n                {\n                    Process.Start(\"open\", url);\n                }\n                else if (OperatingSystem.IsLinux())\n                {\n                    Process.Start(\"xdg-open\", url);\n                }\n                else\n                {\n                    Console.WriteLine($\"Please open your web browser and navigate to: {url}\");\n                }\n\n                await Task.Delay(1000); // Give browser time to start\n            }\n            catch (Exception ex)\n            {\n                Console.WriteLine($\"Failed to open browser automatically: {ex.Message}\");\n                Console.WriteLine($\"Please manually open: http://localhost:{_defaultPort}/PipelineVisualization.html\");\n            }\n        }\n\n        /// <summary>\n        /// Create a default visualization file if one doesn't exist\n        /// This ensures the service can function even if the HTML file is missing\n        /// </summary>\n        private async Task CreateDefaultVisualizationAsync()\n        {\n            var directory = Path.GetDirectoryName(_visualizationPath);\n            if (!string.IsNullOrEmpty(directory))\n            {\n                Directory.CreateDirectory(directory);\n            }\n\n            // The HTML content would be embedded here or loaded from resources\n            // For now, we'll just create a placeholder\n            var defaultHtml = @\"<!DOCTYPE html>\n<html>\n<head>\n    <title>Pipeline Visualization</title>\n</head>\n<body>\n    <h1>Gas Pipeline Network Visualization</h1>\n    <p>This is a placeholder visualization. Please ensure the full visualization HTML file is available.</p>\n    <p>The visualization service attempted to create this file automatically.</p>\n</body>\n</html>\";\n\n            await File.WriteAllTextAsync(_visualizationPath, defaultHtml);\n        }\n\n        /// <summary>\n        /// Generate a static visualization report as an HTML file with embedded data\n        /// This creates a self-contained HTML file that doesn't require a server\n        /// </summary>\n        /// <param name=\"network\">Pipeline network to include</param>\n        /// <param name=\"optimizationResult\">Optimization results to include</param>\n        /// <param name=\"outputPath\">Path for the output HTML file</param>\n        /// <returns>True if report was generated successfully</returns>\n        public async Task<bool> GenerateStaticReportAsync(PipelineNetwork network, OptimizationResult? optimizationResult, string outputPath)\n        {\n            try\n            {\n                // Read the base visualization template\n                var templateContent = await File.ReadAllTextAsync(_visualizationPath);\n\n                // Embed the network and optimization data directly into the HTML\n                var networkJson = JsonSerializer.Serialize(network, new JsonSerializerOptions { WriteIndented = false });\n                var resultJson = optimizationResult != null ? \n                    JsonSerializer.Serialize(optimizationResult, new JsonSerializerOptions { WriteIndented = false }) : \"null\";\n\n                // Inject the data into the HTML template\n                var embeddedScript = $@\"\n<script>\n    // Embedded network and optimization data\n    window.embeddedNetworkData = {networkJson};\n    window.embeddedOptimizationData = {resultJson};\n    \n    // Override the default network loading to use embedded data\n    function loadDefaultNetwork() {{\n        if (window.embeddedNetworkData) {{\n            networkData = window.embeddedNetworkData;\n            if (window.embeddedOptimizationData) {{\n                optimizationResult = window.embeddedOptimizationData;\n            }}\n            refreshVisualization();\n        }}\n    }}\n</script>\";\n\n                // Insert the embedded script before the closing body tag\n                var modifiedContent = templateContent.Replace(\"</body>\", embeddedScript + \"\\n</body>\");\n\n                // Add a header indicating this is a generated report\n                var reportHeader = $@\"\n<!-- Generated Gas Pipeline Optimization Report -->\n<!-- Generated on: {DateTime.Now:yyyy-MM-dd HH:mm:ss} -->\n<!-- Network: {network.Name ?? \"Unknown\"} -->\n<!-- Algorithm: {optimizationResult?.AlgorithmUsed ?? \"N/A\"} -->\n\";\n\n                modifiedContent = modifiedContent.Replace(\"<!DOCTYPE html>\", reportHeader + \"<!DOCTYPE html>\");\n\n                await File.WriteAllTextAsync(outputPath, modifiedContent);\n                \n                Console.WriteLine($\"Static visualization report generated: {outputPath}\");\n                return true;\n            }\n            catch (Exception ex)\n            {\n                Console.WriteLine($\"Failed to generate static report: {ex.Message}\");\n                return false;\n            }\n        }\n    }\n}","size_bytes":19094},"obj/Debug/net8.0/GasPipelineOptimization.AssemblyInfo.cs":{"content":"//------------------------------------------------------------------------------\n// <auto-generated>\n//     This code was generated by a tool.\n//\n//     Changes to this file may cause incorrect behavior and will be lost if\n//     the code is regenerated.\n// </auto-generated>\n//------------------------------------------------------------------------------\n\nusing System;\nusing System.Reflection;\n\n[assembly: System.Reflection.AssemblyCompanyAttribute(\"GasPipelineOptimization\")]\n[assembly: System.Reflection.AssemblyConfigurationAttribute(\"Debug\")]\n[assembly: System.Reflection.AssemblyFileVersionAttribute(\"1.0.0.0\")]\n[assembly: System.Reflection.AssemblyInformationalVersionAttribute(\"1.0.0+3a8e34be69b9b5b5d65fd8db9b96de500d74928e\")]\n[assembly: System.Reflection.AssemblyProductAttribute(\"GasPipelineOptimization\")]\n[assembly: System.Reflection.AssemblyTitleAttribute(\"GasPipelineOptimization\")]\n[assembly: System.Reflection.AssemblyVersionAttribute(\"1.0.0.0\")]\n\n// Generated by the MSBuild WriteCodeFragment class.\n\n","size_bytes":1021},"obj/Debug/net8.0/GasPipelineOptimization.GlobalUsings.g.cs":{"content":"// <auto-generated/>\nglobal using global::System;\nglobal using global::System.Collections.Generic;\nglobal using global::System.IO;\nglobal using global::System.Linq;\nglobal using global::System.Net.Http;\nglobal using global::System.Threading;\nglobal using global::System.Threading.Tasks;\n","size_bytes":287}}}